(()=>{
    "use strict";
    function _define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    class Animation {
        cancel() {
            return __ElementAnimate(this.effect.target.element, [
                3,
                this.id
            ]);
        }
        pause() {
            return __ElementAnimate(this.effect.target.element, [
                2,
                this.id
            ]);
        }
        play() {
            return __ElementAnimate(this.effect.target.element, [
                1,
                this.id
            ]);
        }
        start() {
            return __ElementAnimate(this.effect.target.element, [
                0,
                this.id,
                this.effect.keyframes,
                this.effect.options
            ]);
        }
        constructor(effect){
            _define_property(this, "effect", void 0);
            _define_property(this, "id", void 0);
            this.effect = effect;
            this.id = '__lynx-inner-js-animation-' + Animation.count++;
            this.start();
        }
    }
    _define_property(Animation, "count", 0);
    function effect_define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    class KeyframeEffect {
        constructor(target, keyframes, options){
            effect_define_property(this, "target", void 0);
            effect_define_property(this, "keyframes", void 0);
            effect_define_property(this, "options", void 0);
            this.target = target;
            this.keyframes = keyframes;
            this.options = options;
        }
    }
    function element_define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    let willFlush = false;
    let shouldFlush = true;
    function setShouldFlush(value) {
        shouldFlush = value;
    }
    class Element {
        setAttribute(name, value) {
            __SetAttribute(this.element, name, value);
            this.flushElementTree();
        }
        setStyleProperty(name, value) {
            __AddInlineStyle(this.element, name, value);
            this.flushElementTree();
        }
        setStyleProperties(styles) {
            for(const key in styles)__AddInlineStyle(this.element, key, styles[key]);
            this.flushElementTree();
        }
        getAttribute(attributeName) {
            return __GetAttributeByName(this.element, attributeName);
        }
        getAttributeNames() {
            return __GetAttributeNames(this.element);
        }
        querySelector(selector) {
            const ref = __QuerySelector(this.element, selector, {});
            return ref ? new Element(ref) : null;
        }
        querySelectorAll(selector) {
            return __QuerySelectorAll(this.element, selector, {}).map((element)=>new Element(element));
        }
        animate(keyframes, options) {
            const normalizedOptions = 'number' == typeof options ? {
                duration: options
            } : null != options ? options : {};
            return new Animation(new KeyframeEffect(this, keyframes, normalizedOptions));
        }
        invoke(methodName, params) {
            return new Promise((resolve, reject)=>{
                __InvokeUIMethod(this.element, methodName, null != params ? params : {}, (res)=>{
                    if (0 === res.code) resolve(res.data);
                    else reject(new Error('UI method invoke: ' + JSON.stringify(res)));
                });
                this.flushElementTree();
            });
        }
        flushElementTree() {
            if (willFlush || !shouldFlush) return;
            willFlush = true;
            Promise.resolve().then(()=>{
                willFlush = false;
                __FlushElementTree();
            });
        }
        constructor(element){
            element_define_property(this, "element", void 0);
            Object.defineProperty(this, 'element', {
                get () {
                    return element;
                }
            });
        }
    }
    function lepusQuerySelector_define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    class PageElement {
        static get() {
            var _PageElement;
            null != (_PageElement = PageElement).pageElement || (_PageElement.pageElement = __GetPageElement());
            return PageElement.pageElement;
        }
    }
    lepusQuerySelector_define_property(PageElement, "pageElement", void 0);
    function querySelector(cssSelector) {
        const element = __QuerySelector(PageElement.get(), cssSelector, {});
        return element ? new Element(element) : null;
    }
    function querySelectorAll(cssSelector) {
        return __QuerySelectorAll(PageElement.get(), cssSelector, {}).map((element)=>new Element(element));
    }
    function isSdkVersionGt(major, minor) {
        var _SystemInfo_lynxSdkVersion;
        const lynxSdkVersion = null != (_SystemInfo_lynxSdkVersion = SystemInfo.lynxSdkVersion) ? _SystemInfo_lynxSdkVersion : '1.0';
        const version = lynxSdkVersion.split('.');
        return Number(version[0]) > major || Number(version[0]) == major && Number(version[1]) > minor;
    }
    function initApiEnv() {
        lynx.querySelector = querySelector;
        lynx.querySelectorAll = querySelectorAll;
        globalThis.setTimeout = lynx.setTimeout;
        globalThis.setInterval = lynx.setInterval;
        globalThis.clearTimeout = lynx.clearTimeout;
        var _lynx_clearInterval;
        globalThis.clearInterval = null != (_lynx_clearInterval = lynx.clearInterval) ? _lynx_clearInterval : lynx.clearTimeInterval;
        {
            const requestAnimationFrame = lynx.requestAnimationFrame;
            lynx.requestAnimationFrame = globalThis.requestAnimationFrame = (callback)=>{
                if (!isSdkVersionGt(2, 15)) throw new Error("requestAnimationFrame in main thread script requires Lynx sdk version 2.16");
                return requestAnimationFrame(callback);
            };
        }
        globalThis.cancelAnimationFrame = lynx.cancelAnimationFrame;
    }
    function runRunOnMainThreadTask(task, params, resolveId) {
        let returnValue;
        try {
            returnValue = runWorklet(task, params);
        } finally{
            lynx.getJSContext().dispatchEvent({
                type: "Lynx.Worklet.FunctionCallRet",
                data: JSON.stringify({
                    resolveId,
                    returnValue
                })
            });
        }
    }
    function profile(sliceName, f) {
        console.profile(sliceName);
        try {
            return f();
        } finally{
            console.profileEnd();
        }
    }
    let impl;
    function initWorkletRef() {
        return impl = {
            _workletRefMap: {},
            _firstScreenWorkletRefMap: {},
            updateWorkletRef,
            updateWorkletRefInitValueChanges,
            clearFirstScreenWorkletRefMap
        };
    }
    const createWorkletRef = (id, value)=>({
            current: value,
            _wvid: id
        });
    const getFromWorkletRefMap = (refImpl)=>{
        const id = refImpl._wvid;
        let value;
        if (id < 0) {
            value = impl._firstScreenWorkletRefMap[id];
            if (!value) value = impl._firstScreenWorkletRefMap[id] = createWorkletRef(id, refImpl._initValue);
        } else value = impl._workletRefMap[id];
        if (void 0 === value) throw new Error('Worklet: ref is not initialized: ' + id);
        return value;
    };
    function removeValueFromWorkletRefMap(id) {
        delete impl._workletRefMap[id];
    }
    function updateWorkletRef(handle, element) {
        getFromWorkletRefMap(handle).current = element ? new Element(element) : null;
    }
    function updateWorkletRefInitValueChanges(patch) {
        profile('updateWorkletRefInitValueChanges', ()=>{
            patch.forEach(([id, value])=>{
                if (!impl._workletRefMap[id]) impl._workletRefMap[id] = createWorkletRef(id, value);
            });
        });
    }
    function clearFirstScreenWorkletRefMap() {
        impl._firstScreenWorkletRefMap = {};
    }
    function initEventListeners() {
        const jsContext = lynx.getJSContext();
        jsContext.addEventListener("Lynx.Worklet.runWorkletCtx", (event)=>{
            const data = JSON.parse(event.data);
            runRunOnMainThreadTask(data.worklet, data.params, data.resolveId);
        });
        jsContext.addEventListener("Lynx.Worklet.releaseWorkletRef", (event)=>{
            removeValueFromWorkletRefMap(event.data.id);
        });
    }
    let delayRunOnBackground_impl;
    function initRunOnBackgroundDelay() {
        return delayRunOnBackground_impl = {
            delayedBackgroundFunctionArray: [],
            delayRunOnBackground,
            runDelayedBackgroundFunctions
        };
    }
    function delayRunOnBackground(fnObj, task) {
        var _fnObj;
        delayRunOnBackground_impl.delayedBackgroundFunctionArray.push({
            task
        });
        var __delayIndices;
        const delayIndices = null != (__delayIndices = (_fnObj = fnObj)._delayIndices) ? __delayIndices : _fnObj._delayIndices = [];
        delayIndices.push(delayRunOnBackground_impl.delayedBackgroundFunctionArray.length - 1);
    }
    function runDelayedBackgroundFunctions() {
        for (const details of delayRunOnBackground_impl.delayedBackgroundFunctionArray)if (details.jsFnHandle) details.task(details.jsFnHandle._jsFnId, details.jsFnHandle._execId);
        delayRunOnBackground_impl.delayedBackgroundFunctionArray.length = 0;
    }
    let delayWorkletEvent_impl;
    function initEventDelay() {
        return delayWorkletEvent_impl = {
            _delayedWorkletParamsMap: new Map(),
            runDelayedWorklet,
            clearDelayedWorklets
        };
    }
    function delayExecUntilJsReady(hash, params) {
        profile('delayExecUntilJsReady: ' + hash, ()=>{
            const map = delayWorkletEvent_impl._delayedWorkletParamsMap;
            const paramVec = map.get(hash);
            if (paramVec) paramVec.push(params);
            else map.set(hash, [
                params
            ]);
        });
    }
    function runDelayedWorklet(worklet, element) {
        profile('commitDelayedWorklet', ()=>{
            const paramsVec = delayWorkletEvent_impl._delayedWorkletParamsMap.get(worklet._wkltId);
            if (void 0 === paramsVec) return;
            const leftParamsVec = [];
            paramsVec.forEach((params)=>{
                var _firstParam_currentTarget;
                const firstParam = params[0];
                if ((null == firstParam ? void 0 : null == (_firstParam_currentTarget = firstParam.currentTarget) ? void 0 : _firstParam_currentTarget.elementRefptr) === element) setTimeout(()=>{
                    profile('runDelayedWorklet', ()=>{
                        runWorklet(worklet, params);
                    });
                }, 0);
                else leftParamsVec.push(params);
            });
            delayWorkletEvent_impl._delayedWorkletParamsMap.set(worklet._wkltId, leftParamsVec);
        });
    }
    function clearDelayedWorklets() {
        delayWorkletEvent_impl._delayedWorkletParamsMap.clear();
    }
    function initEomImpl() {
        return {
            setShouldFlush: setShouldFlush
        };
    }
    function hydrateCtx(ctx, firstScreenCtx) {
        profile('hydrateCtx', ()=>{
            hydrateCtxImpl(ctx, firstScreenCtx, ctx._execId);
        });
    }
    function hydrateCtxImpl(ctx, firstScreenCtx, execId) {
        if (!ctx || 'object' != typeof ctx || !firstScreenCtx || 'object' != typeof firstScreenCtx) return;
        const ctxObj = ctx;
        const firstScreenCtxObj = firstScreenCtx;
        if (ctxObj['_wkltId'] && ctxObj['_wkltId'] !== firstScreenCtxObj['_wkltId']) return;
        for(const key in ctx)if ('_wvid' === key) hydrateMainThreadRef(ctxObj[key], firstScreenCtxObj);
        else if ('_jsFn' === key) hydrateDelayRunOnBackgroundTasks(ctxObj[key], firstScreenCtxObj[key], execId);
        else {
            const firstScreenValue = 'function' == typeof firstScreenCtxObj[key] ? firstScreenCtxObj[key].ctx : firstScreenCtxObj[key];
            hydrateCtxImpl(ctxObj[key], firstScreenValue, execId);
        }
    }
    function hydrateMainThreadRef(refId, value) {
        if ('_initValue' in value) return;
        const ref = lynxWorkletImpl._refImpl._workletRefMap[refId];
        ref.current = value.current;
    }
    function hydrateDelayRunOnBackgroundTasks(fnObjs, firstScreenFnObjs, execId) {
        for(const fnName in fnObjs){
            const fnObj = fnObjs[fnName];
            const firstScreenFnObj = firstScreenFnObjs[fnName];
            if (null == firstScreenFnObj ? void 0 : firstScreenFnObj._delayIndices) for (const index of firstScreenFnObj._delayIndices){
                const details = lynxWorkletImpl._runOnBackgroundDelayImpl.delayedBackgroundFunctionArray[index];
                fnObj._execId = execId;
                details.jsFnHandle = fnObj;
            }
        }
    }
    function jsFunctionLifecycle_define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    class JsFunctionLifecycleManager {
        addRef(execId, objToRef) {
            var _this_execIdRefCount_get;
            this.execIdRefCount.set(execId, (null != (_this_execIdRefCount_get = this.execIdRefCount.get(execId)) ? _this_execIdRefCount_get : 0) + 1);
            this.registry.register(objToRef, execId);
        }
        removeRef(execId) {
            const rc = this.execIdRefCount.get(execId);
            if (rc > 1) return void this.execIdRefCount.set(execId, rc - 1);
            this.execIdRefCount.delete(execId);
            this.execIdSetToFire.add(execId);
            if (!this.willFire) {
                this.willFire = true;
                Promise.resolve().then(()=>{
                    this.fire();
                });
            }
        }
        fire() {
            profile('JsFunctionLifecycleManager.fire', ()=>{
                lynx.getJSContext().dispatchEvent({
                    type: "Lynx.Worklet.releaseBackgroundWorkletCtx",
                    data: Array.from(this.execIdSetToFire)
                });
                this.execIdSetToFire.clear();
                this.willFire = false;
            });
        }
        constructor(){
            jsFunctionLifecycle_define_property(this, "execIdRefCount", new Map());
            jsFunctionLifecycle_define_property(this, "execIdSetToFire", new Set());
            jsFunctionLifecycle_define_property(this, "willFire", false);
            jsFunctionLifecycle_define_property(this, "registry", void 0);
            this.registry = new FinalizationRegistry(this.removeRef.bind(this));
        }
    }
    function isRunOnBackgroundEnabled() {
        return isSdkVersionGt(2, 15);
    }
    function initWorklet() {
        globalThis.lynxWorkletImpl = {
            _workletMap: {},
            _refImpl: initWorkletRef(),
            _runOnBackgroundDelayImpl: initRunOnBackgroundDelay(),
            _hydrateCtx: hydrateCtx,
            _eventDelayImpl: initEventDelay(),
            _eomImpl: initEomImpl(),
            _runRunOnMainThreadTask: runRunOnMainThreadTask
        };
        if (isRunOnBackgroundEnabled()) globalThis.lynxWorkletImpl._jsFunctionLifecycleManager = new JsFunctionLifecycleManager();
        globalThis.registerWorklet = registerWorklet;
        globalThis.registerWorkletInternal = registerWorklet;
        globalThis.runWorklet = workletRuntime_runWorklet;
    }
    function registerWorklet(_type, id, worklet) {
        lynxWorkletImpl._workletMap[id] = worklet;
    }
    function workletRuntime_runWorklet(ctx, params) {
        if (!validateWorklet(ctx)) return void console.warn('Worklet: Invalid worklet object: ' + JSON.stringify(ctx));
        if ('_lepusWorkletHash' in ctx) return void delayExecUntilJsReady(ctx._lepusWorkletHash, params);
        return runWorkletImpl(ctx, params);
    }
    function runWorkletImpl(ctx, params) {
        const worklet = profile('transformWorkletCtx ' + ctx._wkltId, ()=>transformWorklet(ctx, true));
        const params_ = profile('transformWorkletParams', ()=>transformWorklet(params || [], false));
        return profile('runWorklet', ()=>worklet(...params_));
    }
    function validateWorklet(ctx) {
        return 'object' == typeof ctx && null !== ctx && ('_wkltId' in ctx || '_lepusWorkletHash' in ctx);
    }
    const workletCache = new WeakMap();
    function transformWorklet(ctx, isWorklet) {
        if ('object' != typeof ctx || null === ctx) return ctx;
        if (isWorklet) {
            const res = workletCache.get(ctx);
            if (res) return res;
        }
        const worklet = {
            main: ctx
        };
        transformWorkletInner(worklet, 0, ctx);
        if (isWorklet) workletCache.set(ctx, worklet.main);
        return worklet.main;
    }
    const transformWorkletInner = (value, depth, ctx)=>{
        const limit = 1000;
        if (++depth >= limit) throw new Error('Depth of value exceeds limit of ' + limit + '.');
        if ('object' != typeof value || null === value) return;
        const obj = value;
        for(const key in obj){
            const subObj = obj[key];
            if ('object' != typeof subObj || null === subObj) continue;
            if ('elementRefptr' in subObj) {
                obj[key] = new Element(subObj['elementRefptr']);
                continue;
            }
            if (subObj instanceof Element) continue;
            transformWorkletInner(subObj, depth, ctx);
            const isWorkletRef = '_wvid' in subObj;
            if (isWorkletRef) {
                obj[key] = getFromWorkletRefMap(subObj);
                continue;
            }
            const isWorklet = '_wkltId' in subObj;
            if (isWorklet) {
                obj[key] = lynxWorkletImpl._workletMap[subObj._wkltId].bind({
                    ...subObj
                });
                obj[key].ctx = subObj;
                continue;
            }
            const isJsFn = '_jsFnId' in subObj;
            if (isJsFn) {
                var _lynxWorkletImpl__jsFunctionLifecycleManager;
                subObj['_execId'] = ctx._execId;
                null == (_lynxWorkletImpl__jsFunctionLifecycleManager = lynxWorkletImpl._jsFunctionLifecycleManager) || _lynxWorkletImpl__jsFunctionLifecycleManager.addRef(ctx._execId, subObj);
                continue;
            }
        }
    };
    if (void 0 === globalThis.lynxWorkletImpl) {
        initWorklet();
        initApiEnv();
        initEventListeners();
    }
})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL2FwaS9hbmltYXRpb24vYW5pbWF0aW9uLnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy9hcGkvYW5pbWF0aW9uL2VmZmVjdC50cyIsIndlYnBhY2s6Ly9AbHlueC1qcy9yZWFjdC13b3JrbGV0LXJ1bnRpbWUvLi9zcmMvYXBpL2VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL2FwaS9sZXB1c1F1ZXJ5U2VsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL3V0aWxzL3ZlcnNpb24udHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL2FwaS9seW54QXBpLnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy9ydW5Pbk1haW5UaHJlYWQudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL3V0aWxzL3Byb2ZpbGUudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL3dvcmtsZXRSZWYudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL2xpc3RlbmVycy50cyIsIndlYnBhY2s6Ly9AbHlueC1qcy9yZWFjdC13b3JrbGV0LXJ1bnRpbWUvLi9zcmMvZGVsYXlSdW5PbkJhY2tncm91bmQudHMiLCJ3ZWJwYWNrOi8vQGx5bngtanMvcmVhY3Qtd29ya2xldC1ydW50aW1lLy4vc3JjL2RlbGF5V29ya2xldEV2ZW50LnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy9lb21JbXBsLnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy9oeWRyYXRlLnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy9qc0Z1bmN0aW9uTGlmZWN5Y2xlLnRzIiwid2VicGFjazovL0BseW54LWpzL3JlYWN0LXdvcmtsZXQtcnVudGltZS8uL3NyYy93b3JrbGV0UnVudGltZS50cyIsIndlYnBhY2s6Ly9AbHlueC1qcy9yZWFjdC13b3JrbGV0LXJ1bnRpbWUvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjUgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB0eXBlIHsgS2V5ZnJhbWVFZmZlY3QgfSBmcm9tICcuL2VmZmVjdC5qcyc7XG5cbmV4cG9ydCBlbnVtIEFuaW1hdGlvbk9wZXJhdGlvbiB7XG4gIFNUQVJUID0gMCwgLy8gU3RhcnQgYSBuZXcgYW5pbWF0aW9uXG4gIFBMQVkgPSAxLCAvLyBQbGF5L3Jlc3VtZSBhIHBhdXNlZCBhbmltYXRpb25cbiAgUEFVU0UgPSAyLCAvLyBQYXVzZSBhbiBleGlzdGluZyBhbmltYXRpb25cbiAgQ0FOQ0VMID0gMywgLy8gQ2FuY2VsIGFuIGFuaW1hdGlvblxufVxuXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgc3RhdGljIGNvdW50ID0gMDtcbiAgcHVibGljIHJlYWRvbmx5IGVmZmVjdDogS2V5ZnJhbWVFZmZlY3Q7XG4gIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGVmZmVjdDogS2V5ZnJhbWVFZmZlY3QpIHtcbiAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDtcbiAgICB0aGlzLmlkID0gJ19fbHlueC1pbm5lci1qcy1hbmltYXRpb24tJyArIEFuaW1hdGlvbi5jb3VudCsrO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWwoKTogdm9pZCB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhY2Nlc3NpbmcgcHJpdmF0ZSBtZW1iZXIgJ2VsZW1lbnQnXG4gICAgcmV0dXJuIF9fRWxlbWVudEFuaW1hdGUodGhpcy5lZmZlY3QudGFyZ2V0LmVsZW1lbnQsIFtBbmltYXRpb25PcGVyYXRpb24uQ0FOQ0VMLCB0aGlzLmlkXSk7XG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhY2Nlc3NpbmcgcHJpdmF0ZSBtZW1iZXIgJ2VsZW1lbnQnXG4gICAgcmV0dXJuIF9fRWxlbWVudEFuaW1hdGUodGhpcy5lZmZlY3QudGFyZ2V0LmVsZW1lbnQsIFtBbmltYXRpb25PcGVyYXRpb24uUEFVU0UsIHRoaXMuaWRdKTtcbiAgfVxuXG4gIHB1YmxpYyBwbGF5KCk6IHZvaWQge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYWNjZXNzaW5nIHByaXZhdGUgbWVtYmVyICdlbGVtZW50J1xuICAgIHJldHVybiBfX0VsZW1lbnRBbmltYXRlKHRoaXMuZWZmZWN0LnRhcmdldC5lbGVtZW50LCBbQW5pbWF0aW9uT3BlcmF0aW9uLlBMQVksIHRoaXMuaWRdKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnQoKTogdm9pZCB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhY2Nlc3NpbmcgcHJpdmF0ZSBtZW1iZXIgJ2VsZW1lbnQnXG4gICAgcmV0dXJuIF9fRWxlbWVudEFuaW1hdGUodGhpcy5lZmZlY3QudGFyZ2V0LmVsZW1lbnQsIFtcbiAgICAgIEFuaW1hdGlvbk9wZXJhdGlvbi5TVEFSVCxcbiAgICAgIHRoaXMuaWQsXG4gICAgICB0aGlzLmVmZmVjdC5rZXlmcmFtZXMsXG4gICAgICB0aGlzLmVmZmVjdC5vcHRpb25zLFxuICAgIF0pO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyNSBUaGUgTHlueCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuaW1wb3J0IHR5cGUgeyBFbGVtZW50IH0gZnJvbSAnLi4vZWxlbWVudC5qcyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlmcmFtZUVmZmVjdCB7XG4gIHB1YmxpYyByZWFkb25seSB0YXJnZXQ6IEVsZW1lbnQ7XG4gIHB1YmxpYyByZWFkb25seSBrZXlmcmFtZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHN0cmluZz5bXTtcbiAgcHVibGljIHJlYWRvbmx5IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdGFyZ2V0OiBFbGVtZW50LFxuICAgIGtleWZyYW1lczogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgc3RyaW5nPltdLFxuICAgIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHN0cmluZz4sXG4gICkge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDI0IFRoZSBMeW54IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5pbXBvcnQgeyBBbmltYXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbi9hbmltYXRpb24uanMnO1xuaW1wb3J0IHsgS2V5ZnJhbWVFZmZlY3QgfSBmcm9tICcuL2FuaW1hdGlvbi9lZmZlY3QuanMnO1xuXG5sZXQgd2lsbEZsdXNoID0gZmFsc2U7XG5sZXQgc2hvdWxkRmx1c2ggPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2hvdWxkRmx1c2godmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgc2hvdWxkRmx1c2ggPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGNsYXNzIEVsZW1lbnQge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHNldCBpbiBjb25zdHJ1Y3RvclxuICBwcml2YXRlIHJlYWRvbmx5IGVsZW1lbnQ6IEVsZW1lbnROb2RlO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnROb2RlKSB7XG4gICAgLy8gSW4gTHlueCB2ZXJzaW9ucyBwcmlvciB0byBhbmQgaW5jbHVkaW5nIDIuMTUsXG4gICAgLy8gYSBjcmFzaCBvY2N1cnMgd2hlbiBwcmludGluZyBvciB0cmFuc2ZlcnJpbmcgcmVmQ291bnRlZCBhY3Jvc3MgdGhyZWFkcy5cbiAgICAvLyBCeXBhc3MgdGhpcyBwcm9ibGVtIGJ5IGhpZGluZyB0aGUgZWxlbWVudCBvYmplY3QuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlbGVtZW50Jywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICBfX1NldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB0aGlzLmZsdXNoRWxlbWVudFRyZWUoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdHlsZVByb3BlcnR5KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIF9fQWRkSW5saW5lU3R5bGUodGhpcy5lbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgdGhpcy5mbHVzaEVsZW1lbnRUcmVlKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0U3R5bGVQcm9wZXJ0aWVzKHN0eWxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgICAgX19BZGRJbmxpbmVTdHlsZSh0aGlzLmVsZW1lbnQsIGtleSwgc3R5bGVzW2tleV0hKTtcbiAgICB9XG4gICAgdGhpcy5mbHVzaEVsZW1lbnRUcmVlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWU6IHN0cmluZyk6IHVua25vd24ge1xuICAgIHJldHVybiBfX0dldEF0dHJpYnV0ZUJ5TmFtZSh0aGlzLmVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcHVibGljIGdldEF0dHJpYnV0ZU5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gX19HZXRBdHRyaWJ1dGVOYW1lcyh0aGlzLmVsZW1lbnQpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3I6IHN0cmluZyk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICBjb25zdCByZWYgPSBfX1F1ZXJ5U2VsZWN0b3IodGhpcy5lbGVtZW50LCBzZWxlY3Rvciwge30pO1xuICAgIHJldHVybiByZWYgPyBuZXcgRWxlbWVudChyZWYpIDogbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yOiBzdHJpbmcpOiBFbGVtZW50W10ge1xuICAgIHJldHVybiBfX1F1ZXJ5U2VsZWN0b3JBbGwodGhpcy5lbGVtZW50LCBzZWxlY3Rvciwge30pLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFuaW1hdGUoXG4gICAga2V5ZnJhbWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCBzdHJpbmc+W10sXG4gICAgb3B0aW9ucz86IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHN0cmluZz4sXG4gICk6IEFuaW1hdGlvbiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgPyB7IGR1cmF0aW9uOiBvcHRpb25zIH0gOiBvcHRpb25zID8/IHt9O1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKG5ldyBLZXlmcmFtZUVmZmVjdCh0aGlzLCBrZXlmcmFtZXMsIG5vcm1hbGl6ZWRPcHRpb25zKSk7XG4gIH1cblxuICBwdWJsaWMgaW52b2tlKFxuICAgIG1ldGhvZE5hbWU6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIF9fSW52b2tlVUlNZXRob2QoXG4gICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgcGFyYW1zID8/IHt9LFxuICAgICAgICAocmVzOiB7IGNvZGU6IG51bWJlcjsgZGF0YTogdW5rbm93biB9KSA9PiB7XG4gICAgICAgICAgaWYgKHJlcy5jb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlcy5kYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVUkgbWV0aG9kIGludm9rZTogJyArIEpTT04uc3RyaW5naWZ5KHJlcykpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdGhpcy5mbHVzaEVsZW1lbnRUcmVlKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZsdXNoRWxlbWVudFRyZWUoKSB7XG4gICAgaWYgKHdpbGxGbHVzaCB8fCAhc2hvdWxkRmx1c2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2lsbEZsdXNoID0gdHJ1ZTtcbiAgICB2b2lkIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgd2lsbEZsdXNoID0gZmFsc2U7XG4gICAgICBfX0ZsdXNoRWxlbWVudFRyZWUoKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnQuanMnO1xuXG5jbGFzcyBQYWdlRWxlbWVudCB7XG4gIHByaXZhdGUgc3RhdGljIHBhZ2VFbGVtZW50OiBFbGVtZW50Tm9kZSB8IHVuZGVmaW5lZDtcblxuICBzdGF0aWMgZ2V0KCkge1xuICAgIFBhZ2VFbGVtZW50LnBhZ2VFbGVtZW50ID8/PSBfX0dldFBhZ2VFbGVtZW50KCk7XG4gICAgcmV0dXJuIFBhZ2VFbGVtZW50LnBhZ2VFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKGNzc1NlbGVjdG9yOiBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gIGNvbnN0IGVsZW1lbnQgPSBfX1F1ZXJ5U2VsZWN0b3IoUGFnZUVsZW1lbnQuZ2V0KCksIGNzc1NlbGVjdG9yLCB7fSk7XG4gIHJldHVybiBlbGVtZW50ID8gbmV3IEVsZW1lbnQoZWxlbWVudCkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChjc3NTZWxlY3Rvcjogc3RyaW5nKTogRWxlbWVudFtdIHtcbiAgcmV0dXJuIF9fUXVlcnlTZWxlY3RvckFsbChQYWdlRWxlbWVudC5nZXQoKSwgY3NzU2VsZWN0b3IsIHt9KS5tYXAoXG4gICAgKGVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuICApO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmV4cG9ydCBmdW5jdGlvbiBpc1Nka1ZlcnNpb25HdChtYWpvcjogbnVtYmVyLCBtaW5vcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGx5bnhTZGtWZXJzaW9uOiBzdHJpbmcgPSBTeXN0ZW1JbmZvLmx5bnhTZGtWZXJzaW9uID8/ICcxLjAnO1xuICBjb25zdCB2ZXJzaW9uID0gbHlueFNka1ZlcnNpb24uc3BsaXQoJy4nKTtcbiAgcmV0dXJuIChcbiAgICBOdW1iZXIodmVyc2lvblswXSkgPiBtYWpvclxuICAgIHx8IChOdW1iZXIodmVyc2lvblswXSkgPT0gbWFqb3IgJiYgTnVtYmVyKHZlcnNpb25bMV0pID4gbWlub3IpXG4gICk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyNCBUaGUgTHlueCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuaW1wb3J0IHsgcXVlcnlTZWxlY3RvciwgcXVlcnlTZWxlY3RvckFsbCB9IGZyb20gJy4vbGVwdXNRdWVyeVNlbGVjdG9yLmpzJztcbmltcG9ydCB7IGlzU2RrVmVyc2lvbkd0IH0gZnJvbSAnLi4vdXRpbHMvdmVyc2lvbi5qcyc7XG5cbmZ1bmN0aW9uIGluaXRBcGlFbnYoKTogdm9pZCB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZVxuICBseW54LnF1ZXJ5U2VsZWN0b3IgPSBxdWVyeVNlbGVjdG9yO1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGVcbiAgbHlueC5xdWVyeVNlbGVjdG9yQWxsID0gcXVlcnlTZWxlY3RvckFsbDtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlXG4gIGdsb2JhbFRoaXMuc2V0VGltZW91dCA9IGx5bnguc2V0VGltZW91dCBhcyAoY2I6ICgpID0+IHZvaWQsIHRpbWVvdXQ6IG51bWJlcikgPT4gbnVtYmVyO1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGVcbiAgZ2xvYmFsVGhpcy5zZXRJbnRlcnZhbCA9IGx5bnguc2V0SW50ZXJ2YWwgYXMgKGNiOiAoKSA9PiB2b2lkLCB0aW1lb3V0OiBudW1iZXIpID0+IG51bWJlcjtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlXG4gIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0ID0gbHlueC5jbGVhclRpbWVvdXQgYXMgKHRpbWVvdXQ6IG51bWJlcikgPT4gdm9pZDtcbiAgLy8gSW4gbHlueCAyLjE0IGBjbGVhckludGVydmFsYCBpcyBtaXN0YWtlbmx5IHNwZWxsZWQgYXMgYGNsZWFyVGltZUludGVydmFsYC4gVGhpcyBpcyBmaXhlZCBpbiBseW54IDIuMTUuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZVxuICBnbG9iYWxUaGlzLmNsZWFySW50ZXJ2YWwgPSAobHlueC5jbGVhckludGVydmFsID8/IGx5bnguY2xlYXJUaW1lSW50ZXJ2YWwpIGFzICh0aW1lb3V0OiBudW1iZXIpID0+IHZvaWQ7XG5cbiAge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZVxuICAgIGNvbnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGx5bngucmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFzIChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4gbnVtYmVyO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZVxuICAgIGx5bngucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsVGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoXG4gICAgICBjYWxsYmFjazogKCkgPT4gdm9pZCxcbiAgICApID0+IHtcbiAgICAgIGlmICghaXNTZGtWZXJzaW9uR3QoMiwgMTUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAncmVxdWVzdEFuaW1hdGlvbkZyYW1lIGluIG1haW4gdGhyZWFkIHNjcmlwdCByZXF1aXJlcyBMeW54IHNkayB2ZXJzaW9uIDIuMTYnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZVxuICBnbG9iYWxUaGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gbHlueC5jYW5jZWxBbmltYXRpb25GcmFtZSBhcyAocmVxdWVzdElkOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB7IGluaXRBcGlFbnYgfTtcbiIsIi8vIENvcHlyaWdodCAyMDI1IFRoZSBMeW54IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5pbXBvcnQgeyBXb3JrbGV0RXZlbnRzIH0gZnJvbSAnLi9iaW5kaW5ncy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7IENsb3N1cmVWYWx1ZVR5cGUsIFJ1bldvcmtsZXRDdHhSZXREYXRhLCBXb3JrbGV0IH0gZnJvbSAnLi9iaW5kaW5ncy9pbmRleC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5SdW5Pbk1haW5UaHJlYWRUYXNrKHRhc2s6IFdvcmtsZXQsIHBhcmFtczogQ2xvc3VyZVZhbHVlVHlwZVtdLCByZXNvbHZlSWQ6IG51bWJlcik6IHZvaWQge1xuICBsZXQgcmV0dXJuVmFsdWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuVmFsdWUgPSBydW5Xb3JrbGV0KHRhc2ssIHBhcmFtcyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIG1vcmUgcHJvcGVyIHRvIHJlamVjdCB0aGUgcHJvbWlzZSBpZiB0aGVyZSBpcyBhbiBlcnJvci5cbiAgICBseW54LmdldEpTQ29udGV4dCgpLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgdHlwZTogV29ya2xldEV2ZW50cy5GdW5jdGlvbkNhbGxSZXQsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHJlc29sdmVJZCxcbiAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICB9IGFzIFJ1bldvcmtsZXRDdHhSZXREYXRhKSxcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmV4cG9ydCBmdW5jdGlvbiBwcm9maWxlPFJldCwgRm4gZXh0ZW5kcyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBSZXQ+KFxuICBzbGljZU5hbWU6IHN0cmluZyxcbiAgZjogRm4sXG4pOiBSZXQge1xuICAvKiB2OCBpZ25vcmUgbmV4dCA5ICovXG4gIC8vIFRPRE86IGNoYW5nZSBpdCB0byBfX1BST0ZJTEVfX1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnNvbGUucHJvZmlsZShzbGljZU5hbWUpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zb2xlLnByb2ZpbGVFbmQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuL2FwaS9lbGVtZW50LmpzJztcbmltcG9ydCB0eXBlIHsgV29ya2xldFJlZiwgV29ya2xldFJlZklkLCBXb3JrbGV0UmVmSW1wbCB9IGZyb20gJy4vYmluZGluZ3MvdHlwZXMuanMnO1xuaW1wb3J0IHsgcHJvZmlsZSB9IGZyb20gJy4vdXRpbHMvcHJvZmlsZS5qcyc7XG5cbmludGVyZmFjZSBSZWZJbXBsIHtcbiAgX3dvcmtsZXRSZWZNYXA6IFJlY29yZDxXb3JrbGV0UmVmSWQsIFdvcmtsZXRSZWY8dW5rbm93bj4+O1xuICBfZmlyc3RTY3JlZW5Xb3JrbGV0UmVmTWFwOiBSZWNvcmQ8V29ya2xldFJlZklkLCBXb3JrbGV0UmVmPHVua25vd24+PjtcbiAgdXBkYXRlV29ya2xldFJlZihcbiAgICByZWZJbXBsOiBXb3JrbGV0UmVmSW1wbDxFbGVtZW50IHwgbnVsbD4sXG4gICAgZWxlbWVudDogRWxlbWVudE5vZGUgfCBudWxsLFxuICApOiB2b2lkO1xuICB1cGRhdGVXb3JrbGV0UmVmSW5pdFZhbHVlQ2hhbmdlcyhwYXRjaDogW251bWJlciwgdW5rbm93bl1bXSk6IHZvaWQ7XG4gIGNsZWFyRmlyc3RTY3JlZW5Xb3JrbGV0UmVmTWFwKCk6IHZvaWQ7XG59XG5cbmxldCBpbXBsOiBSZWZJbXBsIHwgdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpbml0V29ya2xldFJlZigpOiBSZWZJbXBsIHtcbiAgcmV0dXJuIChpbXBsID0ge1xuICAgIF93b3JrbGV0UmVmTWFwOiB7fSxcbiAgICAvKipcbiAgICAgKiBNYXAgb2Ygd29ya2xldCByZWZzIHRoYXQgYXJlIGNyZWF0ZWQgZHVyaW5nIGZpcnN0IHNjcmVlbiByZW5kZXJpbmcuXG4gICAgICogVGhlc2UgcmVmcyBhcmUgY3JlYXRlZCB3aXRoIG5lZ2F0aXZlIElEcyBhbmQgbmVlZCB0byBiZSBoeWRyYXRlZFxuICAgICAqIHdoZW4gdGhlIGFwcCBzdGFydHMuIFRoZSBtYXAgaXMgY2xlYXJlZCBhZnRlciBoeWRyYXRpb24gaXMgY29tcGxldGVcbiAgICAgKiB0byBmcmVlIHVwIG1lbW9yeS5cbiAgICAgKi9cbiAgICBfZmlyc3RTY3JlZW5Xb3JrbGV0UmVmTWFwOiB7fSxcbiAgICB1cGRhdGVXb3JrbGV0UmVmLFxuICAgIHVwZGF0ZVdvcmtsZXRSZWZJbml0VmFsdWVDaGFuZ2VzLFxuICAgIGNsZWFyRmlyc3RTY3JlZW5Xb3JrbGV0UmVmTWFwLFxuICB9KTtcbn1cblxuY29uc3QgY3JlYXRlV29ya2xldFJlZiA9IDxUPihcbiAgaWQ6IFdvcmtsZXRSZWZJZCxcbiAgdmFsdWU6IFQsXG4pOiBXb3JrbGV0UmVmPFQ+ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiB2YWx1ZSxcbiAgICBfd3ZpZDogaWQsXG4gIH07XG59O1xuXG5jb25zdCBnZXRGcm9tV29ya2xldFJlZk1hcCA9IDxUPihcbiAgcmVmSW1wbDogV29ya2xldFJlZkltcGw8VD4sXG4pOiBXb3JrbGV0UmVmPFQ+ID0+IHtcbiAgY29uc3QgaWQgPSByZWZJbXBsLl93dmlkO1xuICBsZXQgdmFsdWU7XG4gIGlmIChpZCA8IDApIHtcbiAgICAvLyBBdCB0aGUgZmlyc3Qgc2NyZWVuIHJlbmRlcmluZywgdGhlIHdvcmtsZXQgcmVmIGlzIGNyZWF0ZWQgd2l0aCBhIG5lZ2F0aXZlIElELlxuICAgIC8vIE1pZ2h0IGJlIGNhbGxlZCBpbiB0d28gc2NlbmFyaW9zOlxuICAgIC8vIDEuIEluIE1UUyBldmVudHNcbiAgICAvLyAyLiBJbiBgbWFpbi10aHJlYWQ6cmVmYFxuICAgIHZhbHVlID0gaW1wbCEuX2ZpcnN0U2NyZWVuV29ya2xldFJlZk1hcFtpZF0gYXMgV29ya2xldFJlZjxUPjtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IGltcGwhLl9maXJzdFNjcmVlbldvcmtsZXRSZWZNYXBbaWRdID0gY3JlYXRlV29ya2xldFJlZihpZCwgcmVmSW1wbC5faW5pdFZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBpbXBsIS5fd29ya2xldFJlZk1hcFtpZF0gYXMgV29ya2xldFJlZjxUPjtcbiAgfVxuXG4gIC8qIHY4IGlnbm9yZSBuZXh0IDMgKi9cbiAgaWYgKF9fREVWX18gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya2xldDogcmVmIGlzIG5vdCBpbml0aWFsaXplZDogJyArIGlkKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiByZW1vdmVWYWx1ZUZyb21Xb3JrbGV0UmVmTWFwKGlkOiBXb3JrbGV0UmVmSWQpOiB2b2lkIHtcbiAgZGVsZXRlIGltcGwhLl93b3JrbGV0UmVmTWFwW2lkXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWxlbWVudCBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBub2RlLCB0aGVuIHNldCB0aGUgd29ya2xldCB2YWx1ZSB0byBpdC5cbiAqIFRoaXMgaXMgY2FsbGVkIGluIGBzbmFwc2hvdENvbnRleHRVcGRhdGVXb3JrbGV0UmVmYC5cbiAqIEBwYXJhbSBoYW5kbGUgaGFuZGxlIG9mIHRoZSB3b3JrbGV0IHZhbHVlLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlV29ya2xldFJlZihcbiAgaGFuZGxlOiBXb3JrbGV0UmVmSW1wbDxFbGVtZW50IHwgbnVsbD4sXG4gIGVsZW1lbnQ6IEVsZW1lbnROb2RlIHwgbnVsbCxcbik6IHZvaWQge1xuICBnZXRGcm9tV29ya2xldFJlZk1hcChoYW5kbGUpLmN1cnJlbnQgPSBlbGVtZW50XG4gICAgPyBuZXcgRWxlbWVudChlbGVtZW50KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya2xldFJlZkluaXRWYWx1ZUNoYW5nZXMoXG4gIHBhdGNoOiBbV29ya2xldFJlZklkLCB1bmtub3duXVtdLFxuKTogdm9pZCB7XG4gIHByb2ZpbGUoJ3VwZGF0ZVdvcmtsZXRSZWZJbml0VmFsdWVDaGFuZ2VzJywgKCkgPT4ge1xuICAgIHBhdGNoLmZvckVhY2goKFtpZCwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoIWltcGwhLl93b3JrbGV0UmVmTWFwW2lkXSkge1xuICAgICAgICBpbXBsIS5fd29ya2xldFJlZk1hcFtpZF0gPSBjcmVhdGVXb3JrbGV0UmVmKGlkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckZpcnN0U2NyZWVuV29ya2xldFJlZk1hcCgpOiB2b2lkIHtcbiAgaW1wbCEuX2ZpcnN0U2NyZWVuV29ya2xldFJlZk1hcCA9IHt9O1xufVxuXG5leHBvcnQge1xuICB0eXBlIFJlZkltcGwsXG4gIGNyZWF0ZVdvcmtsZXRSZWYsXG4gIGluaXRXb3JrbGV0UmVmLFxuICBnZXRGcm9tV29ya2xldFJlZk1hcCxcbiAgcmVtb3ZlVmFsdWVGcm9tV29ya2xldFJlZk1hcCxcbiAgdXBkYXRlV29ya2xldFJlZkluaXRWYWx1ZUNoYW5nZXMsXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB7IFdvcmtsZXRFdmVudHMgfSBmcm9tICcuL2JpbmRpbmdzL2V2ZW50cy5qcyc7XG5pbXBvcnQgdHlwZSB7IFJlbGVhc2VXb3JrbGV0UmVmRGF0YSwgUnVuV29ya2xldEN0eERhdGEgfSBmcm9tICcuL2JpbmRpbmdzL2V2ZW50cy5qcyc7XG5pbXBvcnQgdHlwZSB7IENsb3N1cmVWYWx1ZVR5cGUgfSBmcm9tICcuL2JpbmRpbmdzL3R5cGVzLmpzJztcbmltcG9ydCB7IHJ1blJ1bk9uTWFpblRocmVhZFRhc2sgfSBmcm9tICcuL3J1bk9uTWFpblRocmVhZC5qcyc7XG5pbXBvcnQgdHlwZSB7IEV2ZW50IH0gZnJvbSAnLi90eXBlcy9ydW50aW1lUHJveHkuanMnO1xuaW1wb3J0IHsgcmVtb3ZlVmFsdWVGcm9tV29ya2xldFJlZk1hcCB9IGZyb20gJy4vd29ya2xldFJlZi5qcyc7XG5cbmZ1bmN0aW9uIGluaXRFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgY29uc3QganNDb250ZXh0ID0gbHlueC5nZXRKU0NvbnRleHQoKTtcbiAganNDb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgV29ya2xldEV2ZW50cy5ydW5Xb3JrbGV0Q3R4LFxuICAgIChldmVudDogRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEgYXMgc3RyaW5nKSBhcyBSdW5Xb3JrbGV0Q3R4RGF0YTtcbiAgICAgIHJ1blJ1bk9uTWFpblRocmVhZFRhc2soZGF0YS53b3JrbGV0LCBkYXRhLnBhcmFtcyBhcyBDbG9zdXJlVmFsdWVUeXBlW10sIGRhdGEucmVzb2x2ZUlkKTtcbiAgICB9LFxuICApO1xuICBqc0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBXb3JrbGV0RXZlbnRzLnJlbGVhc2VXb3JrbGV0UmVmLFxuICAgIChldmVudDogRXZlbnQpID0+IHtcbiAgICAgIHJlbW92ZVZhbHVlRnJvbVdvcmtsZXRSZWZNYXAoKGV2ZW50LmRhdGEgYXMgUmVsZWFzZVdvcmtsZXRSZWZEYXRhKS5pZCk7XG4gICAgfSxcbiAgKTtcbn1cblxuZXhwb3J0IHsgaW5pdEV2ZW50TGlzdGVuZXJzIH07XG4iLCIvLyBDb3B5cmlnaHQgMjAyNCBUaGUgTHlueCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuaW1wb3J0IHR5cGUgeyBKc0ZuSGFuZGxlIH0gZnJvbSAnLi9iaW5kaW5ncy90eXBlcy5qcyc7XG5cbmludGVyZmFjZSBEZXRhaWxzIHtcbiAgdGFzazogKGZuSWQ6IG51bWJlciwgZXhlY0lkOiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgLy8gVGhpcyBjb21lcyBmcm9tIHRoZSBiYWNrZ3JvdW5kIHRocmVhZCwgaW5zZXJ0ZWQgaGVyZSBkdXJpbmcgY3R4IGh5ZHJhdGlvbi5cbiAganNGbkhhbmRsZT86IEpzRm5IYW5kbGU7XG59XG5cbmludGVyZmFjZSBSdW5PbkJhY2tncm91bmREZWxheUltcGwge1xuICAvLyBFbGVtZW50cyBzaG91bGQga2VlcCB0aGUgb3JkZXIgYmVpbmcgY2FsbGVkIGJ5IHRoZSB1c2VyLlxuICBkZWxheWVkQmFja2dyb3VuZEZ1bmN0aW9uQXJyYXk6IERldGFpbHNbXTtcbiAgZGVsYXlSdW5PbkJhY2tncm91bmQoZm5PYmo6IEpzRm5IYW5kbGUsIGZuOiAoZm5JZDogbnVtYmVyLCBleGVjSWQ6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQ7XG4gIHJ1bkRlbGF5ZWRCYWNrZ3JvdW5kRnVuY3Rpb25zKCk6IHZvaWQ7XG59XG5cbmxldCBpbXBsOiBSdW5PbkJhY2tncm91bmREZWxheUltcGwgfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluaXRSdW5PbkJhY2tncm91bmREZWxheSgpOiBSdW5PbkJhY2tncm91bmREZWxheUltcGwge1xuICByZXR1cm4gKGltcGwgPSB7XG4gICAgZGVsYXllZEJhY2tncm91bmRGdW5jdGlvbkFycmF5OiBbXSxcbiAgICBkZWxheVJ1bk9uQmFja2dyb3VuZCxcbiAgICBydW5EZWxheWVkQmFja2dyb3VuZEZ1bmN0aW9ucyxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5UnVuT25CYWNrZ3JvdW5kKGZuT2JqOiBKc0ZuSGFuZGxlLCB0YXNrOiAoZm5JZDogbnVtYmVyLCBleGVjSWQ6IG51bWJlcikgPT4gdm9pZCkge1xuICBpbXBsIS5kZWxheWVkQmFja2dyb3VuZEZ1bmN0aW9uQXJyYXkucHVzaCh7IHRhc2sgfSk7XG4gIGNvbnN0IGRlbGF5SW5kaWNlcyA9IGZuT2JqLl9kZWxheUluZGljZXMgPz89IFtdO1xuICBkZWxheUluZGljZXMucHVzaChpbXBsIS5kZWxheWVkQmFja2dyb3VuZEZ1bmN0aW9uQXJyYXkubGVuZ3RoIC0gMSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkRlbGF5ZWRCYWNrZ3JvdW5kRnVuY3Rpb25zKCk6IHZvaWQge1xuICBmb3IgKGNvbnN0IGRldGFpbHMgb2YgaW1wbCEuZGVsYXllZEJhY2tncm91bmRGdW5jdGlvbkFycmF5KSB7XG4gICAgaWYgKGRldGFpbHMuanNGbkhhbmRsZSkge1xuICAgICAgZGV0YWlscy50YXNrKGRldGFpbHMuanNGbkhhbmRsZS5fanNGbklkISwgZGV0YWlscy5qc0ZuSGFuZGxlLl9leGVjSWQhKTtcbiAgICB9XG4gIH1cbiAgaW1wbCEuZGVsYXllZEJhY2tncm91bmRGdW5jdGlvbkFycmF5Lmxlbmd0aCA9IDA7XG59XG5cbmV4cG9ydCB7IHR5cGUgUnVuT25CYWNrZ3JvdW5kRGVsYXlJbXBsLCBpbml0UnVuT25CYWNrZ3JvdW5kRGVsYXkgfTtcbiIsIi8vIENvcHlyaWdodCAyMDI0IFRoZSBMeW54IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5pbXBvcnQgdHlwZSB7IENsb3N1cmVWYWx1ZVR5cGUsIFdvcmtsZXQgfSBmcm9tICcuL2JpbmRpbmdzL3R5cGVzLmpzJztcbmltcG9ydCB7IHByb2ZpbGUgfSBmcm9tICcuL3V0aWxzL3Byb2ZpbGUuanMnO1xuXG5pbnRlcmZhY2UgRXZlbnREZWxheUltcGwge1xuICBfZGVsYXllZFdvcmtsZXRQYXJhbXNNYXA6IE1hcDxzdHJpbmcsIENsb3N1cmVWYWx1ZVR5cGVbXVtdPjtcbiAgcnVuRGVsYXllZFdvcmtsZXQod29ya2xldDogV29ya2xldCwgZWxlbWVudDogRWxlbWVudE5vZGUpOiB2b2lkO1xuICBjbGVhckRlbGF5ZWRXb3JrbGV0cygpOiB2b2lkO1xufVxuXG5sZXQgaW1wbDogRXZlbnREZWxheUltcGwgfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluaXRFdmVudERlbGF5KCk6IEV2ZW50RGVsYXlJbXBsIHtcbiAgcmV0dXJuIChpbXBsID0ge1xuICAgIF9kZWxheWVkV29ya2xldFBhcmFtc01hcDogbmV3IE1hcCgpLFxuICAgIHJ1bkRlbGF5ZWRXb3JrbGV0LFxuICAgIGNsZWFyRGVsYXllZFdvcmtsZXRzLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVsYXlFeGVjVW50aWxKc1JlYWR5KFxuICBoYXNoOiBzdHJpbmcsXG4gIHBhcmFtczogQ2xvc3VyZVZhbHVlVHlwZVtdLFxuKTogdm9pZCB7XG4gIHByb2ZpbGUoJ2RlbGF5RXhlY1VudGlsSnNSZWFkeTogJyArIGhhc2gsICgpID0+IHtcbiAgICBjb25zdCBtYXAgPSBpbXBsIS5fZGVsYXllZFdvcmtsZXRQYXJhbXNNYXA7XG4gICAgY29uc3QgcGFyYW1WZWMgPSBtYXAuZ2V0KGhhc2gpO1xuICAgIGlmIChwYXJhbVZlYykge1xuICAgICAgcGFyYW1WZWMucHVzaChwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXAuc2V0KGhhc2gsIFtwYXJhbXNdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5EZWxheWVkV29ya2xldCh3b3JrbGV0OiBXb3JrbGV0LCBlbGVtZW50OiBFbGVtZW50Tm9kZSk6IHZvaWQge1xuICBwcm9maWxlKCdjb21taXREZWxheWVkV29ya2xldCcsICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXNWZWMgPSBpbXBsIS5fZGVsYXllZFdvcmtsZXRQYXJhbXNNYXAuZ2V0KFxuICAgICAgd29ya2xldC5fd2tsdElkLFxuICAgICk7XG4gICAgaWYgKHBhcmFtc1ZlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRQYXJhbXNWZWM6IENsb3N1cmVWYWx1ZVR5cGVbXVtdID0gW107XG4gICAgcGFyYW1zVmVjLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgZmlyc3RQYXJhbSA9IHBhcmFtc1swXSBhcyB7IGN1cnJlbnRUYXJnZXQ/OiB7IGVsZW1lbnRSZWZwdHI/OiBFbGVtZW50Tm9kZSB9IH0gfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoZmlyc3RQYXJhbT8uY3VycmVudFRhcmdldD8uZWxlbWVudFJlZnB0ciA9PT0gZWxlbWVudCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwcm9maWxlKCdydW5EZWxheWVkV29ya2xldCcsICgpID0+IHtcbiAgICAgICAgICAgIHJ1bldvcmtsZXQod29ya2xldCwgcGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0UGFyYW1zVmVjLnB1c2gocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbXBsIS5fZGVsYXllZFdvcmtsZXRQYXJhbXNNYXAuc2V0KFxuICAgICAgd29ya2xldC5fd2tsdElkLFxuICAgICAgbGVmdFBhcmFtc1ZlYyxcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJEZWxheWVkV29ya2xldHMoKTogdm9pZCB7XG4gIGltcGwhLl9kZWxheWVkV29ya2xldFBhcmFtc01hcC5jbGVhcigpO1xufVxuXG5leHBvcnQgeyB0eXBlIEV2ZW50RGVsYXlJbXBsLCBpbml0RXZlbnREZWxheSwgZGVsYXlFeGVjVW50aWxKc1JlYWR5LCBydW5EZWxheWVkV29ya2xldCwgY2xlYXJEZWxheWVkV29ya2xldHMgfTtcbiIsIi8vIENvcHlyaWdodCAyMDI1IFRoZSBMeW54IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5pbXBvcnQgeyBzZXRTaG91bGRGbHVzaCB9IGZyb20gJy4vYXBpL2VsZW1lbnQuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVvbUltcGwge1xuICBzZXRTaG91bGRGbHVzaCh2YWx1ZTogYm9vbGVhbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RW9tSW1wbCgpOiBFb21JbXBsIHtcbiAgcmV0dXJuIHtcbiAgICBzZXRTaG91bGRGbHVzaCxcbiAgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDI0IFRoZSBMeW54IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cbmltcG9ydCB0eXBlIHsgQ2xvc3VyZVZhbHVlVHlwZSwgSnNGbkhhbmRsZSwgV29ya2xldCwgV29ya2xldFJlZklkLCBXb3JrbGV0UmVmSW1wbCB9IGZyb20gJy4vYmluZGluZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgcHJvZmlsZSB9IGZyb20gJy4vdXRpbHMvcHJvZmlsZS5qcyc7XG5cbi8qKlxuICogSHlkcmF0ZXMgYSBXb3JrbGV0IGNvbnRleHQgd2l0aCBkYXRhIGZyb20gYSBmaXJzdC1zY3JlZW4gV29ya2xldCBjb250ZXh0LlxuICogVGhpcyBwcm9jZXNzIGlzIHR5cGljYWxseSB1c2VkIHRvIHJ1biBhbGwgZGVsYXllZCBgcnVuT25CYWNrZ3JvdW5kYCBmdW5jdGlvbnNcbiAqIGFuZCBpbml0aWFsaXplIGBXb3JrbGV0UmVmYCB2YWx1ZXMgbW9kaWZpZWQgYmVmb3JlIGh5ZHJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gY3R4IFRoZSB0YXJnZXQgV29ya2xldCBjb250ZXh0IHRvIGJlIGh5ZHJhdGVkLlxuICogQHBhcmFtIGZpcnN0U2NyZWVuQ3R4IFRoZSBXb3JrbGV0IGNvbnRleHQgZnJvbSB0aGUgZmlyc3Qgc2NyZWVuIHJlbmRlcmluZyxcbiAqICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nIHRoZSBkYXRhIHRvIGh5ZHJhdGUgd2l0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVDdHgoY3R4OiBXb3JrbGV0LCBmaXJzdFNjcmVlbkN0eDogV29ya2xldCk6IHZvaWQge1xuICBwcm9maWxlKCdoeWRyYXRlQ3R4JywgKCkgPT4ge1xuICAgIGh5ZHJhdGVDdHhJbXBsKGN0eCwgZmlyc3RTY3JlZW5DdHgsIGN0eC5fZXhlY0lkISk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoeWRyYXRlQ3R4SW1wbChjdHg6IENsb3N1cmVWYWx1ZVR5cGUsIGZpcnN0U2NyZWVuQ3R4OiBDbG9zdXJlVmFsdWVUeXBlLCBleGVjSWQ6IG51bWJlcik6IHZvaWQge1xuICBpZiAoIWN0eCB8fCB0eXBlb2YgY3R4ICE9PSAnb2JqZWN0JyB8fCAhZmlyc3RTY3JlZW5DdHggfHwgdHlwZW9mIGZpcnN0U2NyZWVuQ3R4ICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuXG4gIGNvbnN0IGN0eE9iaiA9IGN0eCBhcyBSZWNvcmQ8c3RyaW5nLCBDbG9zdXJlVmFsdWVUeXBlPjtcbiAgY29uc3QgZmlyc3RTY3JlZW5DdHhPYmogPSBmaXJzdFNjcmVlbkN0eCBhcyBSZWNvcmQ8c3RyaW5nLCBDbG9zdXJlVmFsdWVUeXBlPjtcblxuICBpZiAoY3R4T2JqWydfd2tsdElkJ10gJiYgY3R4T2JqWydfd2tsdElkJ10gIT09IGZpcnN0U2NyZWVuQ3R4T2JqWydfd2tsdElkJ10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZvci1pbi1hcnJheVxuICBmb3IgKGNvbnN0IGtleSBpbiBjdHgpIHtcbiAgICBpZiAoa2V5ID09PSAnX3d2aWQnKSB7XG4gICAgICBoeWRyYXRlTWFpblRocmVhZFJlZihjdHhPYmpba2V5XSBhcyBXb3JrbGV0UmVmSWQsIGZpcnN0U2NyZWVuQ3R4T2JqIGFzIHVua25vd24gYXMgV29ya2xldFJlZkltcGw8dW5rbm93bj4pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnX2pzRm4nKSB7XG4gICAgICBoeWRyYXRlRGVsYXlSdW5PbkJhY2tncm91bmRUYXNrcyhcbiAgICAgICAgY3R4T2JqW2tleV0gYXMgUmVjb3JkPHN0cmluZywgSnNGbkhhbmRsZT4sXG4gICAgICAgIGZpcnN0U2NyZWVuQ3R4T2JqW2tleV0gYXMgUmVjb3JkPHN0cmluZywgSnNGbkhhbmRsZT4sXG4gICAgICAgIGV4ZWNJZCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0U2NyZWVuVmFsdWUgPSB0eXBlb2YgZmlyc3RTY3JlZW5DdHhPYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChmaXJzdFNjcmVlbkN0eE9ialtrZXldIGFzIHsgY3R4OiBDbG9zdXJlVmFsdWVUeXBlIH0pLmN0eFxuICAgICAgICA6IGZpcnN0U2NyZWVuQ3R4T2JqW2tleV07XG4gICAgICBoeWRyYXRlQ3R4SW1wbChjdHhPYmpba2V5XSwgZmlyc3RTY3JlZW5WYWx1ZSwgZXhlY0lkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIeWRyYXRlcyBhIFdvcmtsZXRSZWYgb24gdGhlIG1haW4gdGhyZWFkLlxuICogVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgV29ya2xldFJlZidzIGJhY2tncm91bmQgaW5pdGlhbCB2YWx1ZSBiYXNlZCBvbiBjaGFuZ2VzXG4gKiB0aGF0IG9jY3VycmVkIGluIHRoZSBmaXJzdC1zY3JlZW4gV29ya2xldCBjb250ZXh0IGJlZm9yZSBoeWRyYXRpb24uXG4gKlxuICogQHBhcmFtIHJlZklkIFRoZSBJRCBvZiB0aGUgV29ya2xldFJlZiB0byBoeWRyYXRlLlxuICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBXb3JrbGV0UmVmLlxuICovXG5mdW5jdGlvbiBoeWRyYXRlTWFpblRocmVhZFJlZihyZWZJZDogV29ya2xldFJlZklkLCB2YWx1ZTogV29ya2xldFJlZkltcGw8dW5rbm93bj4gfCB7IGN1cnJlbnQ6IHVua25vd24gfSkge1xuICBpZiAoJ19pbml0VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgLy8gVGhlIHJlZiBoYXMgbm90IGJlZW4gYWNjZXNzZWQgeWV0LlxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWYgPSBseW54V29ya2xldEltcGwhLl9yZWZJbXBsLl93b3JrbGV0UmVmTWFwW3JlZklkXSE7XG4gIHJlZi5jdXJyZW50ID0gdmFsdWUuY3VycmVudDtcbn1cblxuLyoqXG4gKiBIeWRyYXRlcyBkZWxheWVkIGBydW5PbkJhY2tncm91bmRgIHRhc2tzLlxuICogVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYW55IGBydW5PbkJhY2tncm91bmRgIGNhbGxzIHRoYXQgd2VyZSBkZWxheWVkXG4gKiBkdXJpbmcgdGhlIGZpcnN0LXNjcmVlbiByZW5kZXJpbmcgYXJlIGNvcnJlY3RseSBhc3NvY2lhdGVkIHdpdGggdGhlaXJcbiAqIHJlc3BlY3RpdmUgSmF2YVNjcmlwdCBmdW5jdGlvbiBoYW5kbGVzIGluIHRoZSBoeWRyYXRlZCBXb3JrbGV0IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGh5ZHJhdGVEZWxheVJ1bk9uQmFja2dyb3VuZFRhc2tzKFxuICBmbk9ianM6IFJlY29yZDxzdHJpbmcsIEpzRm5IYW5kbGU+LCAvLyBleGFtcGxlOiB7XCJfanNGbjFcIjp7XCJfanNGbklkXCI6MX19XG4gIGZpcnN0U2NyZWVuRm5PYmpzOiBSZWNvcmQ8c3RyaW5nLCBKc0ZuSGFuZGxlPiwgLy8gZXhhbXBsZToge1wiX2pzRm4xXCI6e1wiX2lzRmlyc3RTY3JlZW5cIjp0cnVlLFwiX2RlbGF5SW5kaWNlc1wiOlswXX19XG4gIGV4ZWNJZDogbnVtYmVyLFxuKSB7XG4gIGZvciAoY29uc3QgZm5OYW1lIGluIGZuT2Jqcykge1xuICAgIGNvbnN0IGZuT2JqID0gZm5PYmpzW2ZuTmFtZV0hO1xuICAgIGNvbnN0IGZpcnN0U2NyZWVuRm5PYmo6IEpzRm5IYW5kbGUgfCB1bmRlZmluZWQgPSBmaXJzdFNjcmVlbkZuT2Jqc1tmbk5hbWVdO1xuICAgIGlmICghZmlyc3RTY3JlZW5Gbk9iaj8uX2RlbGF5SW5kaWNlcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgZmlyc3RTY3JlZW5Gbk9iai5fZGVsYXlJbmRpY2VzKSB7XG4gICAgICBjb25zdCBkZXRhaWxzID0gbHlueFdvcmtsZXRJbXBsIS5fcnVuT25CYWNrZ3JvdW5kRGVsYXlJbXBsLmRlbGF5ZWRCYWNrZ3JvdW5kRnVuY3Rpb25BcnJheVtpbmRleF0hO1xuICAgICAgZm5PYmouX2V4ZWNJZCA9IGV4ZWNJZDtcbiAgICAgIGRldGFpbHMuanNGbkhhbmRsZSA9IGZuT2JqO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB7IFdvcmtsZXRFdmVudHMgfSBmcm9tICcuL2JpbmRpbmdzL2V2ZW50cy5qcyc7XG5pbXBvcnQgeyBwcm9maWxlIH0gZnJvbSAnLi91dGlscy9wcm9maWxlLmpzJztcbmltcG9ydCB7IGlzU2RrVmVyc2lvbkd0IH0gZnJvbSAnLi91dGlscy92ZXJzaW9uLmpzJztcblxuLyoqXG4gKiBgSnNGdW5jdGlvbkxpZmVjeWNsZU1hbmFnZXJgIG1vbml0b3JzIHJlZmVyZW5jZXMgdG8gSlMgZnVuY3Rpb24gaGFuZGxlcyB0byBiZSBjYWxsZWQgYnkgYHJ1bk9uQmFja2dyb3VuZCgpYC5cbiAqIEluIEpTIGNvbnRleHQsIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQgYnkgYHJ1bk9uQmFja2dyb3VuZCgpYCBpcyByZWZlcmVuY2VkIGJ5IGBKc0ZuSGFuZGxlYHMgYW5kIGZpbmFsbHkgYnkgYGV4ZWNJZGAuXG4gKiBXaGVuIGFsbCBgSnNGbkhhbmRsZWBzIGluIGxlcHVzIGFyZSByZWxlYXNlZCwgYW4gZXZlbnQgd2lsbCBiZSBzZW50IHRvIEpTIGNvbnRleHQgdG8gZGUtcmVmIHRoZSBgZXhlY0lkYCxcbiAqIHJlc3VsdGluZyBhIGRlLXJlZiB0byB0aGUganMgZnVuY3Rpb24gaW4gSlMgY29udGV4dC5cbiAqL1xuY2xhc3MgSnNGdW5jdGlvbkxpZmVjeWNsZU1hbmFnZXIge1xuICBwcml2YXRlIGV4ZWNJZFJlZkNvdW50ID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBleGVjSWRTZXRUb0ZpcmUgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSB3aWxsRmlyZSA9IGZhbHNlO1xuICBwcml2YXRlIHJlZ2lzdHJ5PzogRmluYWxpemF0aW9uUmVnaXN0cnk8bnVtYmVyPiA9IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5PG51bWJlcj4odGhpcy5yZW1vdmVSZWYuYmluZCh0aGlzKSk7XG4gIH1cblxuICBhZGRSZWYoZXhlY0lkOiBudW1iZXIsIG9ialRvUmVmOiBvYmplY3QpOiB2b2lkIHtcbiAgICB0aGlzLmV4ZWNJZFJlZkNvdW50LnNldChcbiAgICAgIGV4ZWNJZCxcbiAgICAgICh0aGlzLmV4ZWNJZFJlZkNvdW50LmdldChleGVjSWQpID8/IDApICsgMSxcbiAgICApO1xuICAgIHRoaXMucmVnaXN0cnkhLnJlZ2lzdGVyKG9ialRvUmVmLCBleGVjSWQpO1xuICB9XG5cbiAgcmVtb3ZlUmVmKGV4ZWNJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgcmMgPSB0aGlzLmV4ZWNJZFJlZkNvdW50LmdldChleGVjSWQpITtcbiAgICBpZiAocmMgPiAxKSB7XG4gICAgICB0aGlzLmV4ZWNJZFJlZkNvdW50LnNldChleGVjSWQsIHJjIC0gMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXhlY0lkUmVmQ291bnQuZGVsZXRlKGV4ZWNJZCk7XG4gICAgdGhpcy5leGVjSWRTZXRUb0ZpcmUuYWRkKGV4ZWNJZCk7XG4gICAgaWYgKCF0aGlzLndpbGxGaXJlKSB7XG4gICAgICB0aGlzLndpbGxGaXJlID0gdHJ1ZTtcbiAgICAgIHZvaWQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZmlyZSgpOiB2b2lkIHtcbiAgICBwcm9maWxlKCdKc0Z1bmN0aW9uTGlmZWN5Y2xlTWFuYWdlci5maXJlJywgKCkgPT4ge1xuICAgICAgbHlueC5nZXRKU0NvbnRleHQoKS5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogV29ya2xldEV2ZW50cy5yZWxlYXNlQmFja2dyb3VuZFdvcmtsZXRDdHgsXG4gICAgICAgIGRhdGE6IEFycmF5LmZyb20odGhpcy5leGVjSWRTZXRUb0ZpcmUpLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmV4ZWNJZFNldFRvRmlyZS5jbGVhcigpO1xuICAgICAgdGhpcy53aWxsRmlyZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUnVuT25CYWNrZ3JvdW5kRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzU2RrVmVyc2lvbkd0KDIsIDE1KTtcbn1cblxuZXhwb3J0IHsgSnNGdW5jdGlvbkxpZmVjeWNsZU1hbmFnZXIsIGlzUnVuT25CYWNrZ3JvdW5kRW5hYmxlZCB9O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjQgVGhlIEx5bnggQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuL2FwaS9lbGVtZW50LmpzJztcbmltcG9ydCB0eXBlIHsgQ2xvc3VyZVZhbHVlVHlwZSwgV29ya2xldCwgV29ya2xldFJlZkltcGwgfSBmcm9tICcuL2JpbmRpbmdzL3R5cGVzLmpzJztcbmltcG9ydCB7IGluaXRSdW5PbkJhY2tncm91bmREZWxheSB9IGZyb20gJy4vZGVsYXlSdW5PbkJhY2tncm91bmQuanMnO1xuaW1wb3J0IHsgZGVsYXlFeGVjVW50aWxKc1JlYWR5LCBpbml0RXZlbnREZWxheSB9IGZyb20gJy4vZGVsYXlXb3JrbGV0RXZlbnQuanMnO1xuaW1wb3J0IHsgaW5pdEVvbUltcGwgfSBmcm9tICcuL2VvbUltcGwuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZUN0eCB9IGZyb20gJy4vaHlkcmF0ZS5qcyc7XG5pbXBvcnQgeyBKc0Z1bmN0aW9uTGlmZWN5Y2xlTWFuYWdlciwgaXNSdW5PbkJhY2tncm91bmRFbmFibGVkIH0gZnJvbSAnLi9qc0Z1bmN0aW9uTGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IHJ1blJ1bk9uTWFpblRocmVhZFRhc2sgfSBmcm9tICcuL3J1bk9uTWFpblRocmVhZC5qcyc7XG5pbXBvcnQgeyBwcm9maWxlIH0gZnJvbSAnLi91dGlscy9wcm9maWxlLmpzJztcbmltcG9ydCB7IGdldEZyb21Xb3JrbGV0UmVmTWFwLCBpbml0V29ya2xldFJlZiB9IGZyb20gJy4vd29ya2xldFJlZi5qcyc7XG5cbmZ1bmN0aW9uIGluaXRXb3JrbGV0KCk6IHZvaWQge1xuICBnbG9iYWxUaGlzLmx5bnhXb3JrbGV0SW1wbCA9IHtcbiAgICBfd29ya2xldE1hcDoge30sXG4gICAgX3JlZkltcGw6IGluaXRXb3JrbGV0UmVmKCksXG4gICAgX3J1bk9uQmFja2dyb3VuZERlbGF5SW1wbDogaW5pdFJ1bk9uQmFja2dyb3VuZERlbGF5KCksXG4gICAgX2h5ZHJhdGVDdHg6IGh5ZHJhdGVDdHgsXG4gICAgX2V2ZW50RGVsYXlJbXBsOiBpbml0RXZlbnREZWxheSgpLFxuICAgIF9lb21JbXBsOiBpbml0RW9tSW1wbCgpLFxuICAgIF9ydW5SdW5Pbk1haW5UaHJlYWRUYXNrOiBydW5SdW5Pbk1haW5UaHJlYWRUYXNrLFxuICB9O1xuXG4gIGlmIChpc1J1bk9uQmFja2dyb3VuZEVuYWJsZWQoKSkge1xuICAgIGdsb2JhbFRoaXMubHlueFdvcmtsZXRJbXBsLl9qc0Z1bmN0aW9uTGlmZWN5Y2xlTWFuYWdlciA9IG5ldyBKc0Z1bmN0aW9uTGlmZWN5Y2xlTWFuYWdlcigpO1xuICB9XG5cbiAgZ2xvYmFsVGhpcy5yZWdpc3RlcldvcmtsZXQgPSByZWdpc3RlcldvcmtsZXQ7XG4gIGdsb2JhbFRoaXMucmVnaXN0ZXJXb3JrbGV0SW50ZXJuYWwgPSByZWdpc3RlcldvcmtsZXQ7XG4gIGdsb2JhbFRoaXMucnVuV29ya2xldCA9IHJ1bldvcmtsZXQ7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB3b3JrbGV0IGZ1bmN0aW9uLCBhbGxvd2luZyBpdCB0byBiZSBleGVjdXRlZCBieSBgcnVuV29ya2xldCgpYC5cbiAqIFRoaXMgaXMgY2FsbGVkIGluIGxlcHVzLmpzLlxuICogQHBhcmFtIF90eXBlIHdvcmtsZXQgdHlwZSwgJ21haW4tdGhyZWFkJyBvciAndWknXG4gKiBAcGFyYW0gaWQgd29ya2xldCBoYXNoXG4gKiBAcGFyYW0gd29ya2xldCB3b3JrbGV0IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyV29ya2xldChfdHlwZTogc3RyaW5nLCBpZDogc3RyaW5nLCB3b3JrbGV0OiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB1bmtub3duKTogdm9pZCB7XG4gIGx5bnhXb3JrbGV0SW1wbC5fd29ya2xldE1hcFtpZF0gPSB3b3JrbGV0O1xufVxuXG4vKipcbiAqIEVudHJhbmNlIG9mIGFsbCB3b3JrbGV0IGNhbGxzLlxuICogTmF0aXZlIGV2ZW50IHRvdWNoIGhhbmRsZXIgd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0gY3R4IHdvcmtsZXQgb2JqZWN0LlxuICogQHBhcmFtIHBhcmFtcyB3b3JrbGV0IHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcnVuV29ya2xldChjdHg6IFdvcmtsZXQsIHBhcmFtczogQ2xvc3VyZVZhbHVlVHlwZVtdKTogdW5rbm93biB7XG4gIGlmICghdmFsaWRhdGVXb3JrbGV0KGN0eCkpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dvcmtsZXQ6IEludmFsaWQgd29ya2xldCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShjdHgpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCdfbGVwdXNXb3JrbGV0SGFzaCcgaW4gY3R4KSB7XG4gICAgZGVsYXlFeGVjVW50aWxKc1JlYWR5KGN0eC5fbGVwdXNXb3JrbGV0SGFzaCwgcGFyYW1zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHJ1bldvcmtsZXRJbXBsKGN0eCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcnVuV29ya2xldEltcGwoY3R4OiBXb3JrbGV0LCBwYXJhbXM6IENsb3N1cmVWYWx1ZVR5cGVbXSk6IHVua25vd24ge1xuICBjb25zdCB3b3JrbGV0OiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB1bmtub3duID0gcHJvZmlsZShcbiAgICAndHJhbnNmb3JtV29ya2xldEN0eCAnICsgY3R4Ll93a2x0SWQsXG4gICAgKCkgPT4gdHJhbnNmb3JtV29ya2xldChjdHgsIHRydWUpLFxuICApO1xuICBjb25zdCBwYXJhbXNfOiBDbG9zdXJlVmFsdWVUeXBlW10gPSBwcm9maWxlKFxuICAgICd0cmFuc2Zvcm1Xb3JrbGV0UGFyYW1zJyxcbiAgICAoKSA9PiB0cmFuc2Zvcm1Xb3JrbGV0KHBhcmFtcyB8fCBbXSwgZmFsc2UpLFxuICApO1xuICByZXR1cm4gcHJvZmlsZSgncnVuV29ya2xldCcsICgpID0+IHdvcmtsZXQoLi4ucGFyYW1zXykpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdvcmtsZXQoY3R4OiB1bmtub3duKTogY3R4IGlzIFdvcmtsZXQge1xuICByZXR1cm4gdHlwZW9mIGN0eCA9PT0gJ29iamVjdCcgJiYgY3R4ICE9PSBudWxsICYmICgnX3drbHRJZCcgaW4gY3R4IHx8ICdfbGVwdXNXb3JrbGV0SGFzaCcgaW4gY3R4KTtcbn1cblxuY29uc3Qgd29ya2xldENhY2hlID0gbmV3IFdlYWtNYXA8b2JqZWN0LCBDbG9zdXJlVmFsdWVUeXBlIHwgKCguLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd24pPigpO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Xb3JrbGV0KGN0eDogV29ya2xldCwgaXNXb3JrbGV0OiB0cnVlKTogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93bjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVdvcmtsZXQoXG4gIGN0eDogQ2xvc3VyZVZhbHVlVHlwZVtdLFxuICBpc1dvcmtsZXQ6IGZhbHNlLFxuKTogQ2xvc3VyZVZhbHVlVHlwZVtdO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Xb3JrbGV0KFxuICBjdHg6IENsb3N1cmVWYWx1ZVR5cGUsXG4gIGlzV29ya2xldDogYm9vbGVhbixcbik6IENsb3N1cmVWYWx1ZVR5cGUgfCAoKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93bikge1xuICAvKiB2OCBpZ25vcmUgbmV4dCAzICovXG4gIGlmICh0eXBlb2YgY3R4ICE9PSAnb2JqZWN0JyB8fCBjdHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgaWYgKGlzV29ya2xldCkge1xuICAgIGNvbnN0IHJlcyA9IHdvcmtsZXRDYWNoZS5nZXQoY3R4KTtcbiAgICBpZiAocmVzKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdvcmtsZXQgPSB7IG1haW46IGN0eCB9O1xuICB0cmFuc2Zvcm1Xb3JrbGV0SW5uZXIod29ya2xldCwgMCwgY3R4KTtcblxuICBpZiAoaXNXb3JrbGV0KSB7XG4gICAgd29ya2xldENhY2hlLnNldChjdHgsIHdvcmtsZXQubWFpbik7XG4gIH1cbiAgcmV0dXJuIHdvcmtsZXQubWFpbjtcbn1cblxuY29uc3QgdHJhbnNmb3JtV29ya2xldElubmVyID0gKFxuICB2YWx1ZTogQ2xvc3VyZVZhbHVlVHlwZSxcbiAgZGVwdGg6IG51bWJlcixcbiAgY3R4OiB1bmtub3duLFxuKSA9PiB7XG4gIGNvbnN0IGxpbWl0ID0gMTAwMDtcbiAgaWYgKCsrZGVwdGggPj0gbGltaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoIG9mIHZhbHVlIGV4Y2VlZHMgbGltaXQgb2YgJyArIGxpbWl0ICsgJy4nKTtcbiAgfVxuICAvKiB2OCBpZ25vcmUgbmV4dCAzICovXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9iaiA9IHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIENsb3N1cmVWYWx1ZVR5cGU+O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHN1Yk9iajogQ2xvc3VyZVZhbHVlVHlwZSA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2Ygc3ViT2JqICE9PSAnb2JqZWN0JyB8fCBzdWJPYmogPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgvKiogaXNFdmVudFRhcmdldCAqLyAnZWxlbWVudFJlZnB0cicgaW4gc3ViT2JqKSB7XG4gICAgICBvYmpba2V5XSA9IG5ldyBFbGVtZW50KHN1Yk9ialsnZWxlbWVudFJlZnB0ciddIGFzIEVsZW1lbnROb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc3ViT2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtV29ya2xldElubmVyKHN1Yk9iaiwgZGVwdGgsIGN0eCk7XG5cbiAgICBjb25zdCBpc1dvcmtsZXRSZWYgPSAnX3d2aWQnIGluIChzdWJPYmogYXMgb2JqZWN0KTtcbiAgICBpZiAoaXNXb3JrbGV0UmVmKSB7XG4gICAgICBvYmpba2V5XSA9IGdldEZyb21Xb3JrbGV0UmVmTWFwKFxuICAgICAgICBzdWJPYmogYXMgdW5rbm93biBhcyBXb3JrbGV0UmVmSW1wbDx1bmtub3duPixcbiAgICAgICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXNXb3JrbGV0ID0gJ193a2x0SWQnIGluIHN1Yk9iajtcbiAgICBpZiAoaXNXb3JrbGV0KSB7XG4gICAgICAvLyBgc3ViT2JqYCBpcyB3b3JrbGV0IGN0eC4gU2hhbGxvdyBjb3B5IGl0IHRvIHByZXZlbnQgdGhlIHRyYW5zZm9ybWVkIHdvcmtsZXQgZnJvbSByZWZlcmVuY2luZyBjdHguXG4gICAgICAvLyBUaGlzIHdvdWxkIHJlc3VsdCBpbiB0aGUgdmFsdWUgb2YgYHdvcmtsZXRDYWNoZWAgcmVmZXJlbmNpbmcgaXRzIGtleS5cbiAgICAgIG9ialtrZXldID0gbHlueFdvcmtsZXRJbXBsLl93b3JrbGV0TWFwWyhzdWJPYmogYXMgV29ya2xldCkuX3drbHRJZF0hXG4gICAgICAgIC5iaW5kKHsgLi4uc3ViT2JqIH0pO1xuICAgICAgb2JqW2tleV0uY3R4ID0gc3ViT2JqO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlzSnNGbiA9ICdfanNGbklkJyBpbiBzdWJPYmo7XG4gICAgaWYgKGlzSnNGbikge1xuICAgICAgc3ViT2JqWydfZXhlY0lkJ10gPSAoY3R4IGFzIFdvcmtsZXQpLl9leGVjSWQ7XG4gICAgICBseW54V29ya2xldEltcGwuX2pzRnVuY3Rpb25MaWZlY3ljbGVNYW5hZ2VyPy5hZGRSZWYoXG4gICAgICAgIChjdHggYXMgV29ya2xldCkuX2V4ZWNJZCEsXG4gICAgICAgIHN1Yk9iaixcbiAgICAgICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCB7IGluaXRXb3JrbGV0IH07XG4iLCIvLyBDb3B5cmlnaHQgMjAyNCBUaGUgTHlueCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuaW1wb3J0IHsgaW5pdEFwaUVudiB9IGZyb20gJy4vYXBpL2x5bnhBcGkuanMnO1xuaW1wb3J0IHsgaW5pdEV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi9saXN0ZW5lcnMuanMnO1xuaW1wb3J0IHsgaW5pdFdvcmtsZXQgfSBmcm9tICcuL3dvcmtsZXRSdW50aW1lLmpzJztcblxuaWYgKGdsb2JhbFRoaXMubHlueFdvcmtsZXRJbXBsID09PSB1bmRlZmluZWQpIHtcbiAgaW5pdFdvcmtsZXQoKTtcbiAgaW5pdEFwaUVudigpO1xuICBpbml0RXZlbnRMaXN0ZW5lcnMoKTtcbn1cbiJdLCJuYW1lcyI6WyJBbmltYXRpb24iLCJfX0VsZW1lbnRBbmltYXRlIiwiZWZmZWN0IiwiS2V5ZnJhbWVFZmZlY3QiLCJ0YXJnZXQiLCJrZXlmcmFtZXMiLCJvcHRpb25zIiwid2lsbEZsdXNoIiwic2hvdWxkRmx1c2giLCJzZXRTaG91bGRGbHVzaCIsInZhbHVlIiwiRWxlbWVudCIsIm5hbWUiLCJfX1NldEF0dHJpYnV0ZSIsIl9fQWRkSW5saW5lU3R5bGUiLCJzdHlsZXMiLCJrZXkiLCJhdHRyaWJ1dGVOYW1lIiwiX19HZXRBdHRyaWJ1dGVCeU5hbWUiLCJfX0dldEF0dHJpYnV0ZU5hbWVzIiwic2VsZWN0b3IiLCJyZWYiLCJfX1F1ZXJ5U2VsZWN0b3IiLCJfX1F1ZXJ5U2VsZWN0b3JBbGwiLCJlbGVtZW50Iiwibm9ybWFsaXplZE9wdGlvbnMiLCJtZXRob2ROYW1lIiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfX0ludm9rZVVJTWV0aG9kIiwicmVzIiwiRXJyb3IiLCJKU09OIiwiX19GbHVzaEVsZW1lbnRUcmVlIiwiT2JqZWN0IiwiUGFnZUVsZW1lbnQiLCJfUGFnZUVsZW1lbnQiLCJfX0dldFBhZ2VFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImNzc1NlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImlzU2RrVmVyc2lvbkd0IiwibWFqb3IiLCJtaW5vciIsIl9TeXN0ZW1JbmZvX2x5bnhTZGtWZXJzaW9uIiwibHlueFNka1ZlcnNpb24iLCJ2ZXJzaW9uIiwiTnVtYmVyIiwiaW5pdEFwaUVudiIsImx5bngiLCJnbG9iYWxUaGlzIiwiX2x5bnhfY2xlYXJJbnRlcnZhbCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGxiYWNrIiwicnVuUnVuT25NYWluVGhyZWFkVGFzayIsInRhc2siLCJyZXNvbHZlSWQiLCJyZXR1cm5WYWx1ZSIsInJ1bldvcmtsZXQiLCJXb3JrbGV0RXZlbnRzIiwicHJvZmlsZSIsInNsaWNlTmFtZSIsImYiLCJjb25zb2xlIiwiaW1wbCIsImluaXRXb3JrbGV0UmVmIiwidXBkYXRlV29ya2xldFJlZiIsInVwZGF0ZVdvcmtsZXRSZWZJbml0VmFsdWVDaGFuZ2VzIiwiY2xlYXJGaXJzdFNjcmVlbldvcmtsZXRSZWZNYXAiLCJjcmVhdGVXb3JrbGV0UmVmIiwiaWQiLCJnZXRGcm9tV29ya2xldFJlZk1hcCIsInJlZkltcGwiLCJ1bmRlZmluZWQiLCJyZW1vdmVWYWx1ZUZyb21Xb3JrbGV0UmVmTWFwIiwiaGFuZGxlIiwicGF0Y2giLCJpbml0RXZlbnRMaXN0ZW5lcnMiLCJqc0NvbnRleHQiLCJldmVudCIsImRhdGEiLCJpbml0UnVuT25CYWNrZ3JvdW5kRGVsYXkiLCJkZWxheVJ1bk9uQmFja2dyb3VuZCIsInJ1bkRlbGF5ZWRCYWNrZ3JvdW5kRnVuY3Rpb25zIiwiZm5PYmoiLCJfZm5PYmoiLCJkZWxheUluZGljZXMiLCJkZXRhaWxzIiwiaW5pdEV2ZW50RGVsYXkiLCJNYXAiLCJydW5EZWxheWVkV29ya2xldCIsImNsZWFyRGVsYXllZFdvcmtsZXRzIiwiZGVsYXlFeGVjVW50aWxKc1JlYWR5IiwiaGFzaCIsIm1hcCIsInBhcmFtVmVjIiwid29ya2xldCIsInBhcmFtc1ZlYyIsImxlZnRQYXJhbXNWZWMiLCJfZmlyc3RQYXJhbV9jdXJyZW50VGFyZ2V0IiwiZmlyc3RQYXJhbSIsInNldFRpbWVvdXQiLCJpbml0RW9tSW1wbCIsImh5ZHJhdGVDdHgiLCJjdHgiLCJmaXJzdFNjcmVlbkN0eCIsImh5ZHJhdGVDdHhJbXBsIiwiZXhlY0lkIiwiY3R4T2JqIiwiZmlyc3RTY3JlZW5DdHhPYmoiLCJoeWRyYXRlTWFpblRocmVhZFJlZiIsImh5ZHJhdGVEZWxheVJ1bk9uQmFja2dyb3VuZFRhc2tzIiwiZmlyc3RTY3JlZW5WYWx1ZSIsInJlZklkIiwibHlueFdvcmtsZXRJbXBsIiwiZm5PYmpzIiwiZmlyc3RTY3JlZW5Gbk9ianMiLCJmbk5hbWUiLCJmaXJzdFNjcmVlbkZuT2JqIiwiaW5kZXgiLCJKc0Z1bmN0aW9uTGlmZWN5Y2xlTWFuYWdlciIsIm9ialRvUmVmIiwiX3RoaXNfZXhlY0lkUmVmQ291bnRfZ2V0IiwicmMiLCJBcnJheSIsIlNldCIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiaXNSdW5PbkJhY2tncm91bmRFbmFibGVkIiwiaW5pdFdvcmtsZXQiLCJyZWdpc3RlcldvcmtsZXQiLCJfdHlwZSIsInZhbGlkYXRlV29ya2xldCIsInJ1bldvcmtsZXRJbXBsIiwidHJhbnNmb3JtV29ya2xldCIsInBhcmFtc18iLCJ3b3JrbGV0Q2FjaGUiLCJXZWFrTWFwIiwiaXNXb3JrbGV0IiwidHJhbnNmb3JtV29ya2xldElubmVyIiwiZGVwdGgiLCJsaW1pdCIsIm9iaiIsInN1Yk9iaiIsImlzV29ya2xldFJlZiIsImlzSnNGbiIsIl9seW54V29ya2xldEltcGxfX2pzRnVuY3Rpb25MaWZlY3ljbGVNYW5hZ2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFZTyxNQUFNQTtRQVdKLFNBQWU7WUFFcEIsT0FBT0MsaUJBQWlCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTs7Z0JBQTRCLElBQUksQ0FBQyxFQUFFO2FBQUM7UUFDMUY7UUFFTyxRQUFjO1lBRW5CLE9BQU9BLGlCQUFpQixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7O2dCQUEyQixJQUFJLENBQUMsRUFBRTthQUFDO1FBQ3pGO1FBRU8sT0FBYTtZQUVsQixPQUFPQSxpQkFBaUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFOztnQkFBMEIsSUFBSSxDQUFDLEVBQUU7YUFBQztRQUN4RjtRQUVRLFFBQWM7WUFFcEIsT0FBT0EsaUJBQWlCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTs7Z0JBRWxELElBQUksQ0FBQyxFQUFFO2dCQUNQLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUztnQkFDckIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPO2FBQ3BCO1FBQ0g7UUE3QkEsWUFBWUMsTUFBc0IsQ0FBRTtZQUhwQyx1QkFBZ0IsVUFBaEI7WUFDQSx1QkFBZ0IsTUFBaEI7WUFHRSxJQUFJLENBQUMsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsK0JBQStCRixVQUFVLEtBQUs7WUFDeEQsSUFBSSxDQUFDLEtBQUs7UUFDWjtJQTBCRjtJQWxDRSxpQkFEV0EsV0FDSixTQUFROzs7Ozs7Ozs7OztJQ1JWLE1BQU1HO1FBS1gsWUFDRUMsTUFBZSxFQUNmQyxTQUE0QyxFQUM1Q0MsT0FBd0MsQ0FDeEM7WUFSRiw2QkFBZ0IsVUFBaEI7WUFDQSw2QkFBZ0IsYUFBaEI7WUFDQSw2QkFBZ0IsV0FBaEI7WUFPRSxJQUFJLENBQUMsTUFBTSxHQUFHRjtZQUNkLElBQUksQ0FBQyxTQUFTLEdBQUdDO1lBQ2pCLElBQUksQ0FBQyxPQUFPLEdBQUdDO1FBQ2pCO0lBQ0Y7Ozs7Ozs7Ozs7O0lDYkEsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxjQUFjO0lBRVgsU0FBU0MsZUFBZUMsS0FBYztRQUMzQ0YsY0FBY0U7SUFDaEI7SUFFTyxNQUFNQztRQWVKLGFBQWFDLElBQVksRUFBRUYsS0FBYyxFQUFRO1lBQ3RERyxlQUFlLElBQUksQ0FBQyxPQUFPLEVBQUVELE1BQU1GO1lBQ25DLElBQUksQ0FBQyxnQkFBZ0I7UUFDdkI7UUFFTyxpQkFBaUJFLElBQVksRUFBRUYsS0FBYSxFQUFRO1lBQ3pESSxpQkFBaUIsSUFBSSxDQUFDLE9BQU8sRUFBRUYsTUFBTUY7WUFDckMsSUFBSSxDQUFDLGdCQUFnQjtRQUN2QjtRQUVPLG1CQUFtQkssTUFBOEIsRUFBUTtZQUM5RCxJQUFLLE1BQU1DLE9BQU9ELE9BQ2hCRCxpQkFBaUIsSUFBSSxDQUFDLE9BQU8sRUFBRUUsS0FBS0QsTUFBTSxDQUFDQyxJQUFJO1lBRWpELElBQUksQ0FBQyxnQkFBZ0I7UUFDdkI7UUFFTyxhQUFhQyxhQUFxQixFQUFXO1lBQ2xELE9BQU9DLHFCQUFxQixJQUFJLENBQUMsT0FBTyxFQUFFRDtRQUM1QztRQUVPLG9CQUE4QjtZQUNuQyxPQUFPRSxvQkFBb0IsSUFBSSxDQUFDLE9BQU87UUFDekM7UUFFTyxjQUFjQyxRQUFnQixFQUFrQjtZQUNyRCxNQUFNQyxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sRUFBRUYsVUFBVSxDQUFDO1lBQ3JELE9BQU9DLE1BQU0sSUFBSVYsUUFBUVUsT0FBTztRQUNsQztRQUVPLGlCQUFpQkQsUUFBZ0IsRUFBYTtZQUNuRCxPQUFPRyxtQkFBbUIsSUFBSSxDQUFDLE9BQU8sRUFBRUgsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUNJLFVBQ2xELElBQUliLFFBQVFhO1FBRXZCO1FBRU8sUUFDTG5CLFNBQTRDLEVBQzVDQyxPQUFrRCxFQUN2QztZQUNYLE1BQU1tQixvQkFBb0IsQUFBbUIsWUFBbkIsT0FBT25CLFVBQXVCO2dCQUFFLFVBQVVBO1lBQVEsSUFBSUEsUUFBQUEsVUFBQUEsVUFBVyxDQUFDO1lBQzVGLE9BQU8sSUFBSU4sVUFBVSxJQUFJRyxlQUFlLElBQUksRUFBRUUsV0FBV29CO1FBQzNEO1FBRU8sT0FDTEMsVUFBa0IsRUFDbEJDLE1BQWdDLEVBQ2Q7WUFDbEIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO2dCQUMzQkMsaUJBQ0UsSUFBSSxDQUFDLE9BQU8sRUFDWkwsWUFDQUMsUUFBQUEsU0FBQUEsU0FBVSxDQUFDLEdBQ1gsQ0FBQ0s7b0JBQ0MsSUFBSUEsQUFBYSxNQUFiQSxJQUFJLElBQUksRUFDVkgsUUFBUUcsSUFBSSxJQUFJO3lCQUVoQkYsT0FBTyxJQUFJRyxNQUFNLHVCQUF1QkMsS0FBSyxTQUFTLENBQUNGO2dCQUUzRDtnQkFFRixJQUFJLENBQUMsZ0JBQWdCO1lBQ3ZCO1FBQ0Y7UUFFUSxtQkFBbUI7WUFDekIsSUFBSXpCLGFBQWEsQ0FBQ0MsYUFDaEI7WUFFRkQsWUFBWTtZQUNQcUIsUUFBUSxPQUFPLEdBQUcsSUFBSSxDQUFDO2dCQUMxQnJCLFlBQVk7Z0JBQ1o0QjtZQUNGO1FBQ0Y7UUFyRkEsWUFBWVgsT0FBb0IsQ0FBRTtZQUZsQyw4QkFBaUIsV0FBakI7WUFNRVksT0FBTyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7Z0JBQ3JDO29CQUNFLE9BQU9aO2dCQUNUO1lBQ0Y7UUFDRjtJQTZFRjs7Ozs7Ozs7Ozs7SUNsR0EsTUFBTWE7UUFHSixPQUFPLE1BQU07Z0JBQ1hDO1lBQUFBLFFBQUFBLEFBQUFBLENBQUFBLGVBQUFBLFdBQVUsRUFBRSxXQUFXLElBQXZCQSxDQUFBQSxhQUFZLFdBQVcsR0FBS0Msa0JBQWlCO1lBQzdDLE9BQU9GLFlBQVksV0FBVztRQUNoQztJQUNGO0lBTkUsbUNBRElBLGFBQ1csZUFBZjtJQVFLLFNBQVNHLGNBQWNDLFdBQW1CO1FBQy9DLE1BQU1qQixVQUFVRixnQkFBZ0JlLFlBQVksR0FBRyxJQUFJSSxhQUFhLENBQUM7UUFDakUsT0FBT2pCLFVBQVUsSUFBSWIsUUFBUWEsV0FBVztJQUMxQztJQUVPLFNBQVNrQixpQkFBaUJELFdBQW1CO1FBQ2xELE9BQU9sQixtQkFBbUJjLFlBQVksR0FBRyxJQUFJSSxhQUFhLENBQUMsR0FBRyxHQUFHLENBQy9ELENBQUNqQixVQUNRLElBQUliLFFBQVFhO0lBR3pCO0lDdEJPLFNBQVNtQixlQUFlQyxLQUFhLEVBQUVDLEtBQWE7WUFDMUJDO1FBQS9CLE1BQU1DLGlCQUF5QkQsUUFBQUEsQ0FBQUEsNkJBQUFBLFdBQVcsY0FBYyxBQUFELElBQXhCQSw2QkFBNkI7UUFDNUQsTUFBTUUsVUFBVUQsZUFBZSxLQUFLLENBQUM7UUFDckMsT0FDRUUsT0FBT0QsT0FBTyxDQUFDLEVBQUUsSUFBSUosU0FDakJLLE9BQU9ELE9BQU8sQ0FBQyxFQUFFLEtBQUtKLFNBQVNLLE9BQU9ELE9BQU8sQ0FBQyxFQUFFLElBQUlIO0lBRTVEO0lDSkEsU0FBU0s7UUFFUEMsS0FBSyxhQUFhLEdBQUdYO1FBRXJCVyxLQUFLLGdCQUFnQixHQUFHVDtRQUV4QlUsV0FBVyxVQUFVLEdBQUdELEtBQUssVUFBVTtRQUV2Q0MsV0FBVyxXQUFXLEdBQUdELEtBQUssV0FBVztRQUV6Q0MsV0FBVyxZQUFZLEdBQUdELEtBQUssWUFBWTtZQUdmRTtRQUE1QkQsV0FBVyxhQUFhLEdBQUlDLFFBQUFBLENBQUFBLHNCQUFBQSxLQUFLLGFBQWEsQUFBRCxJQUFqQkEsc0JBQXNCRixLQUFLLGlCQUFpQjtRQUV4RTtZQUVFLE1BQU1HLHdCQUF3QkgsS0FBSyxxQkFBcUI7WUFFeERBLEtBQUsscUJBQXFCLEdBQUdDLFdBQVcscUJBQXFCLEdBQUcsQ0FDOURHO2dCQUVBLElBQUksQ0FBQ1osZUFBZSxHQUFHLEtBQ3JCLE1BQU0sSUFBSVYsTUFDUjtnQkFHSixPQUFPcUIsc0JBQXNCQztZQUMvQjtRQUNGO1FBR0FILFdBQVcsb0JBQW9CLEdBQUdELEtBQUssb0JBQW9CO0lBQzdEO0lDakNPLFNBQVNLLHVCQUF1QkMsSUFBYSxFQUFFOUIsTUFBMEIsRUFBRStCLFNBQWlCO1FBQ2pHLElBQUlDO1FBQ0osSUFBSTtZQUNGQSxjQUFjQyxXQUFXSCxNQUFNOUI7UUFDakMsU0FBVTtZQUVSd0IsS0FBSyxZQUFZLEdBQUcsYUFBYSxDQUFDO2dCQUNoQyxNQUFNVTtnQkFDTixNQUFNM0IsS0FBSyxTQUFTLENBQUM7b0JBQ25Cd0I7b0JBQ0FDO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lDakJPLFNBQVNHLFFBQ2RDLFNBQWlCLEVBQ2pCQyxDQUFLO1FBS0hDLFFBQVEsT0FBTyxDQUFDRjtRQUNoQixJQUFJO1lBQ0YsT0FBT0M7UUFDVCxTQUFVO1lBQ1JDLFFBQVEsVUFBVTtRQUNwQjtJQUlKO0lDREEsSUFBSUM7SUFFSixTQUFTQztRQUNQLE9BQVFELE9BQU87WUFDYixnQkFBZ0IsQ0FBQztZQU9qQiwyQkFBMkIsQ0FBQztZQUM1QkU7WUFDQUM7WUFDQUM7UUFDRjtJQUNGO0lBRUEsTUFBTUMsbUJBQW1CLENBQ3ZCQyxJQUNBOUQsUUFFTztZQUNMLFNBQVNBO1lBQ1QsT0FBTzhEO1FBQ1Q7SUFHRixNQUFNQyx1QkFBdUIsQ0FDM0JDO1FBRUEsTUFBTUYsS0FBS0UsUUFBUSxLQUFLO1FBQ3hCLElBQUloRTtRQUNKLElBQUk4RCxLQUFLLEdBQUc7WUFLVjlELFFBQVF3RCxLQUFNLHlCQUF5QixDQUFDTSxHQUFHO1lBQzNDLElBQUksQ0FBQzlELE9BQ0hBLFFBQVF3RCxLQUFNLHlCQUF5QixDQUFDTSxHQUFHLEdBQUdELGlCQUFpQkMsSUFBSUUsUUFBUSxVQUFVO1FBRXpGLE9BQ0VoRSxRQUFRd0QsS0FBTSxjQUFjLENBQUNNLEdBQUc7UUFJbEMsSUFBZTlELEFBQVVpRSxXQUFWakUsT0FDYixNQUFNLElBQUl1QixNQUFNLHNDQUFzQ3VDO1FBRXhELE9BQU85RDtJQUNUO0lBRUEsU0FBU2tFLDZCQUE2QkosRUFBZ0I7UUFDcEQsT0FBT04sS0FBTSxjQUFjLENBQUNNLEdBQUc7SUFDakM7SUFRQSxTQUFTSixpQkFDUFMsTUFBc0MsRUFDdENyRCxPQUEyQjtRQUUzQmlELHFCQUFxQkksUUFBUSxPQUFPLEdBQUdyRCxVQUNuQyxJQUFJYixRQUFRYSxXQUNaO0lBQ047SUFFQSxTQUFTNkMsaUNBQ1BTLEtBQWdDO1FBRWhDaEIsUUFBUSxvQ0FBb0M7WUFDMUNnQixNQUFNLE9BQU8sQ0FBQyxDQUFDLENBQUNOLElBQUk5RCxNQUFNO2dCQUN4QixJQUFJLENBQUN3RCxLQUFNLGNBQWMsQ0FBQ00sR0FBRyxFQUMzQk4sS0FBTSxjQUFjLENBQUNNLEdBQUcsR0FBR0QsaUJBQWlCQyxJQUFJOUQ7WUFFcEQ7UUFDRjtJQUNGO0lBRUEsU0FBUzREO1FBQ1BKLEtBQU0seUJBQXlCLEdBQUcsQ0FBQztJQUNyQztJQzlGQSxTQUFTYTtRQUNQLE1BQU1DLFlBQVk3QixLQUFLLFlBQVk7UUFDbkM2QixVQUFVLGdCQUFnQixDQUN4Qm5CLDhCQUNBLENBQUNvQjtZQUNDLE1BQU1DLE9BQU9oRCxLQUFLLEtBQUssQ0FBQytDLE1BQU0sSUFBSTtZQUNsQ3pCLHVCQUF1QjBCLEtBQUssT0FBTyxFQUFFQSxLQUFLLE1BQU0sRUFBd0JBLEtBQUssU0FBUztRQUN4RjtRQUVGRixVQUFVLGdCQUFnQixDQUN4Qm5CLGtDQUNBLENBQUNvQjtZQUNDTCw2QkFBOEJLLE1BQU0sSUFBSSxDQUEyQixFQUFFO1FBQ3ZFO0lBRUo7SUNOQSxJQUFJZjtJQUVKLFNBQVNpQjtRQUNQLE9BQVFqQiw0QkFBTztZQUNiLGdDQUFnQyxFQUFFO1lBQ2xDa0I7WUFDQUM7UUFDRjtJQUNGO0lBRUEsU0FBU0QscUJBQXFCRSxLQUFpQixFQUFFN0IsSUFBNEM7WUFFdEU4QjtRQURyQnJCLDBCQUFNLDhCQUE4QixDQUFDLElBQUksQ0FBQztZQUFFVDtRQUFLOztRQUNqRCxNQUFNK0IsZUFBZUQsUUFBQUEsQ0FBQUEsaUJBQUFBLEFBQUFBLENBQUFBLFNBQUFBLEtBQUksRUFBRSxhQUFhLEFBQUQsSUFBWixpQkFBTkEsT0FBTSxhQUFhLEdBQUssRUFBRTtRQUMvQ0MsYUFBYSxJQUFJLENBQUN0QiwwQkFBTSw4QkFBOEIsQ0FBQyxNQUFNLEdBQUc7SUFDbEU7SUFFQSxTQUFTbUI7UUFDUCxLQUFLLE1BQU1JLFdBQVd2QiwwQkFBTSw4QkFBOEIsQ0FDeEQsSUFBSXVCLFFBQVEsVUFBVSxFQUNwQkEsUUFBUSxJQUFJLENBQUNBLFFBQVEsVUFBVSxDQUFDLE9BQU8sRUFBR0EsUUFBUSxVQUFVLENBQUMsT0FBTztRQUd4RXZCLDBCQUFNLDhCQUE4QixDQUFDLE1BQU0sR0FBRztJQUNoRDtJQzlCQSxJQUFJQTtJQUVKLFNBQVN3QjtRQUNQLE9BQVF4Qix5QkFBTztZQUNiLDBCQUEwQixJQUFJeUI7WUFDOUJDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBLFNBQVNDLHNCQUNQQyxJQUFZLEVBQ1pwRSxNQUEwQjtRQUUxQm1DLFFBQVEsNEJBQTRCaUMsTUFBTTtZQUN4QyxNQUFNQyxNQUFNOUIsdUJBQU0sd0JBQXdCO1lBQzFDLE1BQU0rQixXQUFXRCxJQUFJLEdBQUcsQ0FBQ0Q7WUFDekIsSUFBSUUsVUFDRkEsU0FBUyxJQUFJLENBQUN0RTtpQkFFZHFFLElBQUksR0FBRyxDQUFDRCxNQUFNO2dCQUFDcEU7YUFBTztRQUUxQjtJQUNGO0lBRUEsU0FBU2lFLGtCQUFrQk0sT0FBZ0IsRUFBRTFFLE9BQW9CO1FBQy9Ec0MsUUFBUSx3QkFBd0I7WUFDOUIsTUFBTXFDLFlBQVlqQyx1QkFBTSx3QkFBd0IsQ0FBQyxHQUFHLENBQ2xEZ0MsUUFBUSxPQUFPO1lBRWpCLElBQUlDLEFBQWN4QixXQUFkd0IsV0FDRjtZQUVGLE1BQU1DLGdCQUFzQyxFQUFFO1lBQzlDRCxVQUFVLE9BQU8sQ0FBQyxDQUFDeEU7b0JBRWIwRTtnQkFESixNQUFNQyxhQUFhM0UsTUFBTSxDQUFDLEVBQUU7Z0JBQzVCLElBQUkwRSxBQUFBQSxDQUFBQSxRQUFBQSxhQUFBQSxLQUFBQSxJQUFBQSxRQUFBQSxDQUFBQSw0QkFBQUEsV0FBWSxhQUFhLEFBQUQsSUFBeEJBLEtBQUFBLElBQUFBLDBCQUEyQixhQUFhLEFBQUQsTUFBTTdFLFNBQy9DK0UsV0FBVztvQkFDVHpDLFFBQVEscUJBQXFCO3dCQUMzQkYsV0FBV3NDLFNBQVN2RTtvQkFDdEI7Z0JBQ0YsR0FBRztxQkFFSHlFLGNBQWMsSUFBSSxDQUFDekU7WUFFdkI7WUFDQXVDLHVCQUFNLHdCQUF3QixDQUFDLEdBQUcsQ0FDaENnQyxRQUFRLE9BQU8sRUFDZkU7UUFFSjtJQUNGO0lBRUEsU0FBU1A7UUFDUDNCLHVCQUFNLHdCQUF3QixDQUFDLEtBQUs7SUFDdEM7SUMxRE8sU0FBU3NDO1FBQ2QsT0FBTztZQUNML0YsZ0JBQWNBO1FBQ2hCO0lBQ0Y7SUNHTyxTQUFTZ0csV0FBV0MsR0FBWSxFQUFFQyxjQUF1QjtRQUM5RDdDLFFBQVEsY0FBYztZQUNwQjhDLGVBQWVGLEtBQUtDLGdCQUFnQkQsSUFBSSxPQUFPO1FBQ2pEO0lBQ0Y7SUFFQSxTQUFTRSxlQUFlRixHQUFxQixFQUFFQyxjQUFnQyxFQUFFRSxNQUFjO1FBQzdGLElBQUksQ0FBQ0gsT0FBTyxBQUFlLFlBQWYsT0FBT0EsT0FBb0IsQ0FBQ0Msa0JBQWtCLEFBQTBCLFlBQTFCLE9BQU9BLGdCQUE2QjtRQUU5RixNQUFNRyxTQUFTSjtRQUNmLE1BQU1LLG9CQUFvQko7UUFFMUIsSUFBSUcsTUFBTSxDQUFDLFVBQVUsSUFBSUEsTUFBTSxDQUFDLFVBQVUsS0FBS0MsaUJBQWlCLENBQUMsVUFBVSxFQUN6RTtRQUlGLElBQUssTUFBTS9GLE9BQU8wRixJQUNoQixJQUFJMUYsQUFBUSxZQUFSQSxLQUNGZ0cscUJBQXFCRixNQUFNLENBQUM5RixJQUFJLEVBQWtCK0Y7YUFDN0MsSUFBSS9GLEFBQVEsWUFBUkEsS0FDVGlHLGlDQUNFSCxNQUFNLENBQUM5RixJQUFJLEVBQ1grRixpQkFBaUIsQ0FBQy9GLElBQUksRUFDdEI2RjthQUVHO1lBQ0wsTUFBTUssbUJBQW1CLEFBQWtDLGNBQWxDLE9BQU9ILGlCQUFpQixDQUFDL0YsSUFBSSxHQUNqRCtGLGlCQUFpQixDQUFDL0YsSUFBSSxDQUErQixHQUFHLEdBQ3pEK0YsaUJBQWlCLENBQUMvRixJQUFJO1lBQzFCNEYsZUFBZUUsTUFBTSxDQUFDOUYsSUFBSSxFQUFFa0csa0JBQWtCTDtRQUNoRDtJQUVKO0lBVUEsU0FBU0cscUJBQXFCRyxLQUFtQixFQUFFekcsS0FBcUQ7UUFDdEcsSUFBSSxnQkFBZ0JBLE9BRWxCO1FBRUYsTUFBTVcsTUFBTStGLGdCQUFpQixRQUFRLENBQUMsY0FBYyxDQUFDRCxNQUFNO1FBQzNEOUYsSUFBSSxPQUFPLEdBQUdYLE1BQU0sT0FBTztJQUM3QjtJQVFBLFNBQVN1RyxpQ0FDUEksTUFBa0MsRUFDbENDLGlCQUE2QyxFQUM3Q1QsTUFBYztRQUVkLElBQUssTUFBTVUsVUFBVUYsT0FBUTtZQUMzQixNQUFNL0IsUUFBUStCLE1BQU0sQ0FBQ0UsT0FBTztZQUM1QixNQUFNQyxtQkFBMkNGLGlCQUFpQixDQUFDQyxPQUFPO1lBQzFFLElBQUtDLFFBQUFBLG1CQUFBQSxLQUFBQSxJQUFBQSxpQkFBa0IsYUFBYSxFQUdwQyxLQUFLLE1BQU1DLFNBQVNELGlCQUFpQixhQUFhLENBQUU7Z0JBQ2xELE1BQU0vQixVQUFVMkIsZ0JBQWlCLHlCQUF5QixDQUFDLDhCQUE4QixDQUFDSyxNQUFNO2dCQUNoR25DLE1BQU0sT0FBTyxHQUFHdUI7Z0JBQ2hCcEIsUUFBUSxVQUFVLEdBQUdIO1lBQ3ZCO1FBQ0Y7SUFDRjs7Ozs7Ozs7Ozs7SUM5RUEsTUFBTW9DO1FBVUosT0FBT2IsTUFBYyxFQUFFYyxRQUFnQixFQUFRO2dCQUcxQ0M7WUFGSCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FDckJmLFFBQ0NlLEFBQUFBLFNBQUFBLENBQUFBLDJCQUFBQSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQ2YsT0FBTSxJQUE5QmUsMkJBQW1DLEtBQUs7WUFFM0MsSUFBSSxDQUFDLFFBQVEsQ0FBRSxRQUFRLENBQUNELFVBQVVkO1FBQ3BDO1FBRUEsVUFBVUEsTUFBYyxFQUFRO1lBQzlCLE1BQU1nQixLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDaEI7WUFDbkMsSUFBSWdCLEtBQUssR0FBRyxZQUNWLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDaEIsUUFBUWdCLEtBQUs7WUFHdkMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUNoQjtZQUMzQixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQ0E7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxRQUFRLEdBQUc7Z0JBQ1hqRixRQUFRLE9BQU8sR0FBRyxJQUFJLENBQUM7b0JBQzFCLElBQUksQ0FBQyxJQUFJO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLE9BQWE7WUFDWGtDLFFBQVEsbUNBQW1DO2dCQUN6Q1gsS0FBSyxZQUFZLEdBQUcsYUFBYSxDQUFDO29CQUNoQyxNQUFNVTtvQkFDTixNQUFNaUUsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWU7Z0JBQ3ZDO2dCQUNBLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSztnQkFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRztZQUNsQjtRQUNGO1FBckNBLGFBQWM7WUFMZCwwQ0FBUSxrQkFBaUIsSUFBSW5DO1lBQzdCLDBDQUFRLG1CQUFrQixJQUFJb0M7WUFDOUIsMENBQVEsWUFBVztZQUNuQiwwQ0FBUSxZQUEwQ3BEO1lBR2hELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSXFELHFCQUE2QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJO1FBQzNFO0lBb0NGO0lBRUEsU0FBU0M7UUFDUCxPQUFPdEYsZUFBZSxHQUFHO0lBQzNCO0lDL0NBLFNBQVN1RjtRQUNQOUUsV0FBVyxlQUFlLEdBQUc7WUFDM0IsYUFBYSxDQUFDO1lBQ2QsVUFBVWU7WUFDViwyQkFBMkJnQjtZQUMzQixhQUFhc0I7WUFDYixpQkFBaUJmO1lBQ2pCLFVBQVVjO1lBQ1YseUJBQXlCaEQ7UUFDM0I7UUFFQSxJQUFJeUUsNEJBQ0Y3RSxXQUFXLGVBQWUsQ0FBQywyQkFBMkIsR0FBRyxJQUFJc0U7UUFHL0R0RSxXQUFXLGVBQWUsR0FBRytFO1FBQzdCL0UsV0FBVyx1QkFBdUIsR0FBRytFO1FBQ3JDL0UsV0FBVyxVQUFVLEdBQUdRO0lBQzFCO0lBU0EsU0FBU3VFLGdCQUFnQkMsS0FBYSxFQUFFNUQsRUFBVSxFQUFFMEIsT0FBd0M7UUFDMUZrQixnQkFBZ0IsV0FBVyxDQUFDNUMsR0FBRyxHQUFHMEI7SUFDcEM7SUFRQSxTQUFTdEMsMEJBQVc4QyxHQUFZLEVBQUUvRSxNQUEwQjtRQUMxRCxJQUFJLENBQUMwRyxnQkFBZ0IzQixNQUFNLFlBQ3pCekMsUUFBUSxJQUFJLENBQUMsc0NBQXNDL0IsS0FBSyxTQUFTLENBQUN3RTtRQUdwRSxJQUFJLHVCQUF1QkEsS0FBSyxZQUM5Qlosc0JBQXNCWSxJQUFJLGlCQUFpQixFQUFFL0U7UUFHL0MsT0FBTzJHLGVBQWU1QixLQUFLL0U7SUFDN0I7SUFFQSxTQUFTMkcsZUFBZTVCLEdBQVksRUFBRS9FLE1BQTBCO1FBQzlELE1BQU11RSxVQUEyQ3BDLFFBQy9DLHlCQUF5QjRDLElBQUksT0FBTyxFQUNwQyxJQUFNNkIsaUJBQWlCN0IsS0FBSztRQUU5QixNQUFNOEIsVUFBOEIxRSxRQUNsQywwQkFDQSxJQUFNeUUsaUJBQWlCNUcsVUFBVSxFQUFFLEVBQUU7UUFFdkMsT0FBT21DLFFBQVEsY0FBYyxJQUFNb0MsV0FBV3NDO0lBQ2hEO0lBRUEsU0FBU0gsZ0JBQWdCM0IsR0FBWTtRQUNuQyxPQUFPLEFBQWUsWUFBZixPQUFPQSxPQUFvQkEsQUFBUSxTQUFSQSxPQUFpQixjQUFhQSxPQUFPLHVCQUF1QkEsR0FBRTtJQUNsRztJQUVBLE1BQU0rQixlQUFlLElBQUlDO0lBUXpCLFNBQVNILGlCQUNQN0IsR0FBcUIsRUFDckJpQyxTQUFrQjtRQUdsQixJQUFJLEFBQWUsWUFBZixPQUFPakMsT0FBb0JBLEFBQVEsU0FBUkEsS0FDN0IsT0FBT0E7UUFHVCxJQUFJaUMsV0FBVztZQUNiLE1BQU0zRyxNQUFNeUcsYUFBYSxHQUFHLENBQUMvQjtZQUM3QixJQUFJMUUsS0FDRixPQUFPQTtRQUVYO1FBRUEsTUFBTWtFLFVBQVU7WUFBRSxNQUFNUTtRQUFJO1FBQzVCa0Msc0JBQXNCMUMsU0FBUyxHQUFHUTtRQUVsQyxJQUFJaUMsV0FDRkYsYUFBYSxHQUFHLENBQUMvQixLQUFLUixRQUFRLElBQUk7UUFFcEMsT0FBT0EsUUFBUSxJQUFJO0lBQ3JCO0lBRUEsTUFBTTBDLHdCQUF3QixDQUM1QmxJLE9BQ0FtSSxPQUNBbkM7UUFFQSxNQUFNb0MsUUFBUTtRQUNkLElBQUksRUFBRUQsU0FBU0MsT0FDYixNQUFNLElBQUk3RyxNQUFNLHFDQUFxQzZHLFFBQVE7UUFHL0QsSUFBSSxBQUFpQixZQUFqQixPQUFPcEksU0FBc0JBLEFBQVUsU0FBVkEsT0FDL0I7UUFFRixNQUFNcUksTUFBTXJJO1FBRVosSUFBSyxNQUFNTSxPQUFPK0gsSUFBSztZQUNyQixNQUFNQyxTQUEyQkQsR0FBRyxDQUFDL0gsSUFBSTtZQUN6QyxJQUFJLEFBQWtCLFlBQWxCLE9BQU9nSSxVQUF1QkEsQUFBVyxTQUFYQSxRQUNoQztZQUdGLElBQXlCLG1CQUFtQkEsUUFBUTtnQkFDbERELEdBQUcsQ0FBQy9ILElBQUksR0FBRyxJQUFJTCxRQUFRcUksTUFBTSxDQUFDLGdCQUFnQjtnQkFDOUM7WUFDRjtZQUFPLElBQUlBLGtCQUFrQnJJLFNBQzNCO1lBR0ZpSSxzQkFBc0JJLFFBQVFILE9BQU9uQztZQUVyQyxNQUFNdUMsZUFBZSxXQUFZRDtZQUNqQyxJQUFJQyxjQUFjO2dCQUNoQkYsR0FBRyxDQUFDL0gsSUFBSSxHQUFHeUQscUJBQ1R1RTtnQkFFRjtZQUNGO1lBQ0EsTUFBTUwsWUFBWSxhQUFhSztZQUMvQixJQUFJTCxXQUFXO2dCQUdiSSxHQUFHLENBQUMvSCxJQUFJLEdBQUdvRyxnQkFBZ0IsV0FBVyxDQUFFNEIsT0FBbUIsT0FBTyxDQUFDLENBQ2hFLElBQUksQ0FBQztvQkFBRSxHQUFHQSxNQUFNO2dCQUFDO2dCQUNwQkQsR0FBRyxDQUFDL0gsSUFBSSxDQUFDLEdBQUcsR0FBR2dJO2dCQUNmO1lBQ0Y7WUFDQSxNQUFNRSxTQUFTLGFBQWFGO1lBQzVCLElBQUlFLFFBQVE7b0JBRVZDO2dCQURBSCxNQUFNLENBQUMsVUFBVSxHQUFJdEMsSUFBZ0IsT0FBTzt3QkFDNUN5QyxDQUFBQSwrQ0FBQUEsZ0JBQWdCLDJCQUEyQixBQUFELEtBQTFDQSw2Q0FBNkMsTUFBTSxDQUNoRHpDLElBQWdCLE9BQU8sRUFDeEJzQztnQkFFRjtZQUNGO1FBQ0Y7SUFDRjtJQ2pLQSxJQUFJNUYsQUFBK0J1QixXQUEvQnZCLFdBQVcsZUFBZSxFQUFnQjtRQUM1QzhFO1FBQ0FoRjtRQUNBNkI7SUFDRiJ9